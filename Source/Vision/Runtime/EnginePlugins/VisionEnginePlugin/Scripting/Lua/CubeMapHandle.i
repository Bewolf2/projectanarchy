/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

#ifndef VLUA_APIDOC

%nodefaultctor CubeMapHandle_cl;
%nodefaultdtor CubeMapHandle_cl;
 
class CubeMapHandle_cl : public VisBaseEntity_cl
{
public:

  void SetActivate(bool bStatus);

  VTextureObject* GetCubeMapTexture();

  inline int  GetSize() const;

  inline void SetContinuousUpdate(bool bStatus);
  inline void SetAlternatingUpdate(bool bStatus);
  inline bool GetContinuousUpdate() const;

  inline void SetUpdateParams(float fInterval, int iCount);
  
  void Invalidate();

  int GetBlurPasses() const;

  bool GetAutoGenMipMaps() const;

  %extend{
    VSWIG_BITMASK_SETTER(SetRenderFilterMask);
    VSWIG_BITMASK_GETTER_CONST(GetRenderFilterMask);
  }
};

//add lua tostring and concat operators
VSWIG_CREATE_CONCAT(CubeMapHandle_cl, 128, "[%s : %1.2f,%1.2f,%1.2f]", self->GetObjectKey(), self->GetPosition().x, self->GetPosition().y, self->GetPosition().z )
VSWIG_CREATE_TOSTRING(CubeMapHandle_cl, "CubeMapHandle_cl [%s : %1.2f,%1.2f,%1.2f - %dpx]", self->GetObjectKey(), self->GetPosition().x, self->GetPosition().y, self->GetPosition().z, self->GetSize())

//implement GetClipPlanes native because we would like to return two values at once
%native(CubeMapHandle_cl_GetClipPlanes) int CubeMapHandle_cl_GetClipPlanes(lua_State *L);
%{
  SWIGINTERN int CubeMapHandle_cl_GetClipPlanes(lua_State *L)
  {
    IS_MEMBER_OF(CubeMapHandle_cl) //this will move this function to the method table of the specified class
        
    SWIG_CONVERT_POINTER(L, 1, CubeMapHandle_cl, pCubemap)
    lua_pop(L, 1); //clean the stack (self is not needed any more)
    
    float fNear, fFar;
    pCubemap->GetClipPlanes(fNear, fFar);
        
    lua_pushnumber(L, (lua_Number)fNear);
    lua_pushnumber(L, (lua_Number)fFar);
    
    return 2; //in every case we leave two values at the stack
  }
%}

//implement GetClipPlanes native because we would like to return two values at once
%native(CubeMapHandle_cl_GetUpdateParams) int CubeMapHandle_cl_GetUpdateParams(lua_State *L);
%{
  SWIGINTERN int CubeMapHandle_cl_GetUpdateParams(lua_State *L)
  {
    IS_MEMBER_OF(CubeMapHandle_cl) //this will move this function to the method table of the specified class
        
    SWIG_CONVERT_POINTER(L, 1, CubeMapHandle_cl, pCubemap)
    lua_pop(L, 1); //clean the stack (self is not needed any more)
    
    float fInterval;
    int iCount;
    pCubemap->GetUpdateParams(fInterval, iCount);
        
    lua_pushnumber(L, (lua_Number)fInterval);
    lua_pushnumber(L, (lua_Number)iCount);
    
    return 2; //in every case we leave two values at the stack
  }
%}

#else

/// \brief
///   Wrapper class for CubeMapHandle_cl.
/// 
/// The cubemap textures generated by this entity class can be referenced by the cubemap's key.
/// 
/// Cubemap should be accessed with caution.
/// \brief Forces a cubemap update in the next frame.
/// \par Example
///   \code
///     -- lua script is attached to a cubemap
///     function OnThink(self)
///       if inputMap:GetTrigger("FREEZE") then
///         self:SetActivate(false)
///       end
///     end
///   \endcode
class CubeMapHandle_cl : public VisBaseEntity_cl
{
public:

  /// @name CubeMap Setup
  /// @{
  
  /// \brief Activates or deactivates continuous cubemap rendering.
  /// \param activate Set to true in order to activate , otherwise false.
  void SetActivate(boolean activate);

  /// \brief Returns the clip plane distances set via SetClipPlanes.
  /// \return The distances for the clip planes, first the near, then the far clip plane.
  /// \brief Forces a cubemap update in the next frame.
  /// \par Example
  ///   \code
  ///     local nearCP, farCP = cubemap:GetClipPlanes()
  ///   \endcode
  multiple GetClipPlanes();

  /// \brief Returns the edge size of the cubemap.
  /// \return The pixel size of the cubemap.
  number GetSize();
  
  /// \brief Sets a render filter bitmask that is used for rendering scene elements.
  /// \param mask The bitmask used for rendering.
  void SetRenderFilterMask(VBitmask mask);
  
  /// \brief Returns the render filter bitmask.
  /// \return The filter bitmask as VBitmask.
  VBitmask GetRenderFilterMask();
  
  /// \brief Returns the number of gaussian blur passes applied to the cubemap each time it is updated.
  /// \return The number of blur passes.
  number GetBlurPasses();
  
  /// \brief Check if  automatic mipmap generation for this cubemap is enabled.
  /// \return True if auto generation is enabled, otherwse false.
  boolean GetAutoGenMipMaps();

  /// @}
  /// @name CubeMap Update Functions
  /// @{

  /// \brief Sets the flag for continuous cubemap update. If false, the cubemap gets only rendered at creation time.
  /// \param enable Set to true in order to enable continous updates, otherwise false.
  void SetContinuousUpdate(boolean enable);

  /// \brief Gets the flag for continuous cubemap update.
  /// \return True if continuous update is enabled.
  boolean GetContinuousUpdate();
  
  /// \brief If enabled, only one cubemap face is rendered per frame/update rather than all six faces at the same time. The default status is false.
  /// \param enable Set to true in order to enable the alternatig update.
  void SetAlternatingUpdate(boolean enable);
  
  /// \brief Sets the update interval (in seconds) and the update count of the cubemap.
  /// \param interval The Interval (in seconds) can be set to 0.0 to update every frame.
  /// \param count The number of available updates for this cubemap. Use 0 for infinite updates.
  void SetUpdateParams(number interval, number count);

  /// \brief Returns the update parameters (see SetUpdateParams).
  /// \return First the update interval, followed by the update count.
  /// \par Example
  ///   \code
  ///     local interval, count = cubemap:GetUpdateParams()
  ///   \endcode
  multiple GetUpdateParams();
  
  /// @}
  /// @name CubeMap Common Functions
  /// @{
  
  /// \brief Access the associated textre.
  /// \return Returns the texture object associated with this cubemap instance.
  VTextureObject GetCubeMapTexture();

  /// \brief Forces a cubemap update in the next frame.
  /// \par Example
  ///   \code
  ///     -- lua script is attached to a cubemap
  ///     function OnThink(self)
  ///       if Input:IsKeyPressed(Vision.KEY_SPACE) then
  ///         self:Invalidate()
  ///       end
  ///     end
  ///   \endcode
  void Invalidate();

  /// @}
};

#endif

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
