/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

/// \file VType.hpp

#ifndef _VISION_VTYPE_HPP
#define _VISION_VTYPE_HPP

class VString;
class VArchive;
class VTypedObject;
class VResourceSnapshot;
class VSerializationContext;
struct VType;
class VResourceManager;

struct V_REGISTER_CLASS;
#define V_RUNTIME_CLASS(classname) ((VType*)(&classname::class##classname))

#include <Vision/Runtime/Base/Graphics/Shader/vShaderConstants.hpp>
#include <Vision/Runtime/Base/Container/VLinkedList.hpp>
#include <Vision/Runtime/Base/Container/VTraits.hpp>

class VCallback;

///////////////////////////////////////////////////////////////////////////////
// Variable management
///////////////////////////////////////////////////////////////////////////////


/// \brief
///  Optional flags for a VType variable list
enum VVARIABLELIST_FLAGS_e
{
  VVARIABLELIST_FLAGS_NONE    = 0,
  VFORGE_HIDECLASS            = V_BIT(0),  ///< don't enum this class in vForge
  VCOMPONENT_ALLOW_MULTIPLE   = V_BIT(1),  ///< components use this flag to determine whether multiple instances of the same type can be attached to one object
  VFORGE_USE_NATIVE_PARENTING = V_BIT(2)   ///< entities can use this flag to enforce scene graph update through native parenting functions inside vForge. No effect on the runtime side
};

/// \brief
///  Return options for the VTypedObject::OnVariableValueChanging callback
enum VVarChangeRes_e
{
  VCHANGE_IS_REDUNDANT, ///< the variable is already set to the specified value, OnVariableValueChanged will not occur, set is successful
  VCHANGE_IS_CANCELLED, ///< the variable cannot be changed to the specified value, OnVariableValueChanged will not occur, set is unsuccessful
  VCHANGE_IS_ALLOWED,   ///< the variable can be changed to the specified value, OnVariableValueChanged will occur, set is successful
};

/// \brief
///  Structure that gets passed to virtual VTypedObject::GetVariableAttributes function to modify per instance variable attributes in the editor
struct VVariableAttributeInfo
{
public:
  inline VVariableAttributeInfo()
  {
    m_bReadOnly = false;
    m_bHidden = false;
    m_bSyncCurrentValue = false;
  }

  bool m_bReadOnly; ///< Set to true do display a variable in read-only mode (grayed out)
  bool m_bHidden;   ///< Set to true do hide a variable
  bool m_bSyncCurrentValue; ///< If set to true, the current value of the native variable will be read back into the editor properties using the overridable VTypedObject::GetVariableValue function 
};


#ifndef _VISION_DOC

  class VisVariable_cl;

  #define VARIABLE_ELEM LinkedList_Element_cl<VisVariable_cl*>

  class VARIABLE_LIST : public LinkedList_cl<VisVariable_cl*>
  {
  public:
    VBASE_IMPEXP VARIABLE_LIST(const char* szDesc, int iFlags, const char* szModel);
    VBASE_IMPEXP ~VARIABLE_LIST();

    const char *m_szVarList_Desc;
    VVARIABLELIST_FLAGS_e m_iVarList_Flags;
    const char *m_szCustomModel;
  };

#endif //_VISION_DOC


#define MAX_VARNAME_LEN 31
////////////////////////////////////////////////////////////////////////////

/// \brief
///   This class holds class specific variables in the RTTI system
///
/// Instances of VisVariable_cl are implicitly generated by the DEFINE_VAR_xyz macros. Pointer to a VisVariable_cl are
/// passed to VTypedObject::OnVariableValueChanging and VTypedObject::OnVariableValueChanged to identify variables.
///
/// \sa VTypedObject
class VisVariable_cl
{
public:
  VBASE_IMPEXP VisVariable_cl();

  /// \brief
  ///   Abstract base class for variable conversion of higher level types.
  ///
  /// Using a converter object in order to perform conversion is necessary if an object can only 
  /// be created on higher levels of abstraction (e.g. shader effects should be created by using 
  /// Vision::Shaders).
  struct VisVariableObjectValueConverter
  {
    // virtual destructor
    virtual ~VisVariableObjectValueConverter(){}

    /// \brief
    ///   Converts from string to the respective variable type.
    ///
    /// \param szStr
    ///   String representation of the object.
    virtual void *StringToObjectValue(const char* szStr) = 0;

    /// \brief
    ///   Converts from the respective variable type to string.
    ///
    /// \param pObject
    ///   Pointer to an object of the respective type.
    ///
    /// \param szStr
    ///   String representation of the object (output).
    virtual void ObjectValueToString(const void* pObject, char* szStr) = 0;
  };

  /// \brief
  ///   Return the name of the variable
  inline const char *GetName() const {return (name != NULL) ? name : "";}

  /// \brief
  ///   Returns the string used as the display name in GUIs. Should NOT be used for identifying objects (ie. serialization).
  inline const char* GetDisplayName () const { return m_szDisplayName != NULL ? m_szDisplayName : name; }

  ///
  /// @name Access per-instance variable values
  /// @{
  ///

  /// \brief
  ///   Get the current variable value as set in the passed object. The value is written to the passed string, e.g. "0.01" for a float type variable
  ///
  /// \param obj
  ///   The instance to retrieve the variable value from. Should be an instance of class derived from VTypedObject
  /// \param str
  ///   The target string buffer to write the value
  /// \param bClassObject
  ///   Deprecated; should be true
  VBASE_IMPEXP void GetValue(void *obj,char *str,bool bClassObject = true);

  /// \brief
  ///   Set the variable value on the passed object. The new value is passed as a string, e.g. "0.01" for a float type variable
  ///
  /// \param obj
  ///   The instance to modify. Should be an instance of class derived from VTypedObject
  /// \param str
  ///   The string buffer containing the value to set.
  /// \param bClassObject
  ///   Deprecated; should be true
  VBASE_IMPEXP void SetValue(void *obj,const char *str,bool bClassObject = true);

  /// \brief
  ///   Get the current variable value as set in the passed object. The value is copied directly into the passed memory pointer, e.g. it copies 4 bytes for a float type variable
  ///
  /// \param obj
  ///   The instance to retrieve the variable value from. Should be an instance of class derived from VTypedObject
  /// \param ptr
  ///   The target pointer to copy the variable value
  /// \param bClassObject
  ///   Deprecated; should be true
  VBASE_IMPEXP void GetValueDirect(void *obj,void *ptr,bool bClassObject = true);

  /// \brief
  ///   Setter counterpart for function GetValueDirect
  VBASE_IMPEXP void SetValueDirect(void *obj,void *ptr,bool bClassObject = true);

  /// \brief
  ///   Access the value as a float3 vector. Assumes the variable is of type int-, float- or double vector
  ///
  /// \param obj
  ///   The instance to retrieve the variable value from. Should be an instance of class derived from VTypedObject
  /// \param x
  ///   Receives the x component of the vector
  /// \param y
  ///   Receives the y component of the vector
  /// \param z
  ///   Receives the z component of the vector
  /// \param bClassObject
  ///   Deprecated; should be true
  VBASE_IMPEXP void GetVector(void *obj,float &x,float &y,float &z,bool bClassObject = true);

  /// \brief
  ///   Setter counterpart for function GetVector
  VBASE_IMPEXP void SetVector(void *obj,float x,float y,float z,bool bClassObject = true);

  /// \brief
  ///   Access a value at given index in a vector variable. Assumes the variable is of type int-, float- or double vector
  ///
  /// \param obj
  ///   The instance to retrieve the variable value from. Should be an instance of class derived from VTypedObject
  /// \param index
  ///   0-based component index (must be 0..2)
  /// \param str
  ///   Buffer to write the value to
  /// \param bClassObject
  ///   Deprecated; should be true
  VBASE_IMPEXP void GetIndexedValue(void *obj,int index, char *str,bool bClassObject = true);

  /// \brief
  ///   Setter counterpart for function GetIndexedValue
  VBASE_IMPEXP void SetIndexedValue(void *obj,int index, char *str,bool bClassObject = true);

  /// \brief
  ///   Resets the variable value to the default value defined in the variable definition
  ///
  /// \param obj
  ///   The instance to modify. Should be an instance of class derived from VTypedObject
  /// \param bClassObject
  ///   Deprecated; should be true
  VBASE_IMPEXP void LoadDefaultValue(void *obj,bool bClassObject = true);

  /// \brief
  ///   DEPRECATED internal function
  VBASE_IMPEXP bool IsDataOwnByVar();

  ///
  /// @}
  ///

  ///
  /// @name Enum variables
  /// @{
  ///

  /// \brief
  ///   Returns the number of enum values in case this variable is an enum
  VBASE_IMPEXP int GetEnumCount();

  /// \brief
  ///   Returns the name of enum item with index num. name must have enough space for MAX_NAMELEN+1 characters
  VBASE_IMPEXP void GetEnumField(int num,char *name);
  
  /// \brief
  ///   Returns the number of the enum item called "name", -1 if not found
  VBASE_IMPEXP int FindEnumField(const char *name);

  /// \brief  Equality operator. Checks just name and type!
  /// \param  other  The variable used for comparison.
  /// \return true if the variables are considered equivalent.
  inline bool operator==(const VisVariable_cl & other) const
  {
    return type==other.type&&(name==other.name||(name!=NULL&&other.name!=NULL&&strcmp(name, other.name)==0));
  };

  /// \brief  Not Equality operator. Checks just name and type!
  /// \param  other  The variable used for comparison.
  /// \return true if the variables are NOT considered equivalent.
  inline bool operator!=(const VisVariable_cl & other) const
  {
    return type!=other.type||(name!=other.name&&(name==NULL||other.name==NULL||strcmp(name, other.name)!=0));
  };

  ///
  /// @}
  ///

  ///
  /// @name global variable creation/deletion
  /// @{
  ///

  /// \brief
  ///   Global function to create a new variable instance
  static VBASE_IMPEXP VisVariable_cl* NewVariable(const char *name, const char *desc, int type, int offs, const char *def, VDisplayHintFlags_e hints, const char *szEditorHintStr, size_t extra=0, const char* szDisplayName = NULL);

  /// \brief
  ///   Global function to delete a variable instance
  static VBASE_IMPEXP void DeleteVariable(VisVariable_cl* pVariable);

  ///
  /// @}
  ///

//members
  const char *name; ///< Name of the variable
  const char* m_szDisplayName;  ///< A string used ONLY for display in C#
  int type;                     ///< Variable type; casted to enum type VulpType_e
  const char *defaultValue;     ///< String that represents the default value, e.g. "0.01"
  const char *desc;             ///< description text for the variable; shown in vForge
  const char *category;         ///< variable category
  const char *editorHintString; ///< additional property editor definition fro vFOrge. See documentation
  size_t extraInfo;   ///< length for strings, opt. for enum.....
  int clsOffset;      ///< offset in object class, can be -1 for no update
  int offset;         ///< offset in memory chunk (deprecated)
  VDisplayHintFlags_e hintFlags;  ///< hint flags for vForge property editors
  VisVariable_cl *m_pNextVar;     ///< next linked list entry

  VBASE_IMPEXP static const char *s_szActiveCategory; ///< this one temporarily stores the category name
  VBASE_IMPEXP static VisVariableObjectValueConverter *s_pStringToShaderEffectConverter;
};  



///////////////////////////////////////////////////////
// base class helper macros
///////////////////////////////////////////////////////

#ifdef _WIN64  
  #define EXPECTED_VTYPE_SIZE   88
  #define EXPECTED_VTYPE_OFFSET 24
#else  
  #define EXPECTED_VTYPE_SIZE   48
  #define EXPECTED_VTYPE_OFFSET 16
#endif


/// \brief
///   Macro that has to be put into the header declaration to add RTTI capabilities to a class.
///
/// See RTTI documentation for differences regarding V_DECLARE_xyz macros
#define V_DECLARE_DYNAMIC(class_name) \
public: \
  static VType class##class_name; \
  static VType *GetClassTypeId(); \
  virtual VType *GetTypeId() const;

/// \brief
///   Macro that has to be put into the header declaration to add RTTI capabilities to a class.
///
/// Uses V_DECLARE_DYNAMIC and additionally adds the CreateObject function for dynamic instantiation
#define V_DECLARE_DYNCREATE(class_name) \
  V_DECLARE_DYNAMIC(class_name) \
  static VTypedObject* CreateObject();


/// \brief
///   Macro that has to be put into the header to let instances of the classes be allocated
///   at aligned memory positions.
///
#ifdef HK_DEBUG
#define V_DECLARE_OVERRIDE_NEWDELETE_ALIGNED(alignment) \
  inline void *operator new (size_t iSize) \
  { \
    return VBaseObject::operator new(iSize,alignment); \
  } \
  inline void operator delete(void *p) \
  { \
    VBaseObject::operator delete(p, alignment); \
  } \
  inline void *operator new (size_t iSize, const char* pFile, int iLine) \
  { \
    return VBaseObject::operator new(iSize,alignment,pFile,iLine); \
  } \
  inline void operator delete(void *p, const char* pFile, int iLine) \
  { \
    VBaseObject::operator delete(p, alignment,pFile,iLine); \
  }
#else
#define V_DECLARE_OVERRIDE_NEWDELETE_ALIGNED(alignment) \
  inline void *operator new (size_t iSize) \
  { \
    return VBaseObject::operator new(iSize,alignment); \
  } \
  inline void operator delete(void *p) \
  { \
    VBaseObject::operator delete(p, alignment); \
  }
#endif

/// \brief
///   Macro that has to be put into the header declaration to add RTTI capabilities to a class.
///
/// Uses V_DECLARE_DYNCREATE and additionally overloads the '>>', ''<<' operators for VArchive serialization
#define V_DECLARE_SERIAL(class_name, imp_exp_spec) \
  V_DECLARE_DYNCREATE(class_name) \
  friend imp_exp_spec VArchive& operator>>( VArchive& ar, class_name* &pObj );

/// \brief
///   Macro that has to be put into the header declaration to add aligned memory and RTTI capabilities to a class.
///
#define V_DECLARE_SERIAL_ALIGNED(class_name, imp_exp_spec, alignment) \
  V_DECLARE_DYNCREATE(class_name) \
  friend imp_exp_spec VArchive& operator>>( VArchive& ar, class_name* &pObj );\
  V_DECLARE_OVERRIDE_NEWDELETE_ALIGNED(alignment)

/// \brief
///   Macro that has to be put into the header declaration to add RTTI capabilities to a class.
///
/// Same as V_DECLARE_DYNAMIC but with DLL linkage type so functions can be exported. Required when plugin functionality
/// should be accessible outside the plugin.
#define V_DECLARE_DYNAMIC_DLLEXP(class_name, imp_exp_spec) \
public: \
  static imp_exp_spec VType class##class_name; \
  static imp_exp_spec VType *GetClassTypeId(); \
  virtual imp_exp_spec VType *GetTypeId() const;

/// \brief
///   Optionally adds a variable table to this class. This macro must be specified in the header.
#define V_DECLARE_VARTABLE(class_name, imp_exp_spec) \
  static imp_exp_spec void class_name##_BuildVarList(class VARIABLE_LIST *pList);            \
  static imp_exp_spec void class_name##_DeInitVarList(class VARIABLE_LIST *pList);


/// \brief
///   Macro that has to be put into the header declaration to add RTTI capabilities to a class.
///
/// Same as V_DECLARE_DYNCREATE but with DLL linkage type so functions can be exported. Required when plugin functionality
/// should be accessible outside the plugin.
#define V_DECLARE_DYNCREATE_DLLEXP(class_name, imp_exp_spec) \
  V_DECLARE_DYNAMIC_DLLEXP(class_name, imp_exp_spec) \
  static imp_exp_spec VTypedObject* CreateObject();


/// \brief
///   Macro that has to be put into the header declaration to add RTTI capabilities to a class.
///
/// Same as V_DECLARE_SERIAL but with DLL linkage type so functions can be exported. Required when plugin functionality
/// should be accessible outside the plugin.
#define V_DECLARE_SERIAL_DLLEXP(class_name, imp_exp_spec) \
  V_DECLARE_DYNCREATE_DLLEXP(class_name, imp_exp_spec) \
  friend imp_exp_spec VArchive& operator>>( VArchive& ar, class_name* &pObj );

/// \brief
///   Macro that has to be put into the header declaration to add aligned memory and RTTI capabilities to a class.
///
/// Same as V_DECLARE_SERIAL_ALIGNED but with DLL linkage type so functions can be exported. Required when plugin functionality
/// should be accessible outside the plugin.
#define V_DECLARE_SERIAL_ALIGNED_DLLEXP(class_name, imp_exp_spec, alignment) \
  V_DECLARE_DYNCREATE_DLLEXP(class_name, imp_exp_spec) \
  friend imp_exp_spec VArchive& operator>>( VArchive& ar, class_name* &pObj ); \
  V_DECLARE_OVERRIDE_NEWDELETE_ALIGNED(alignment)


/// \brief
///   Base macro that has to be put into the cpp to add RTTI capabilities to a class.
#define V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, plugin_source) \
  VType class_name::class##class_name = { \
    #class_name, pfnNew, sizeof(class class_name), wSchema,   \
    /* m_pBaseClass     = */ V_RUNTIME_CLASS(base_class_name),\
    /* m_pModule        = */ plugin_source,   \
    /* m_pParamDesc     = */ NULL,            \
    /* GetFullParamDesc = */ NULL,    \
    /* m_bFullParamInit = */ FALSE,   \
    /* m_pVarList       = */ NULL,    \
    /* m_iReserved  = */ 0, \
    /* m_pNextType      = */ NULL };  \
  VType *class_name::GetClassTypeId()                               \
    {                                                               \
     V_COMPILE_ASSERT( sizeof(class_name::class##class_name)== EXPECTED_VTYPE_SIZE ); \
     V_COMPILE_ASSERT( offsetof(VType,m_pBaseClass) == EXPECTED_VTYPE_OFFSET ); \
     return V_RUNTIME_CLASS(class_name);                            \
    }                                                               \
  VType *class_name::GetTypeId() const \
    { return V_RUNTIME_CLASS(class_name); } \
  V_REGISTER_CLASS _init_##class_name(V_RUNTIME_CLASS(class_name)); 

/// \brief
///   This macro is the cpp counterpart of V_DECLARE_DYNAMIC. See RTTI documentation for sample code
#define V_IMPLEMENT_DYNAMIC(class_name, base_class_name,plugin_source) \
  V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL, plugin_source)

/// \brief
///   This macro is the cpp counterpart of V_DECLARE_DYNCREATE. See RTTI documentation for sample code
#define V_IMPLEMENT_DYNCREATE(class_name, base_class_name,plugin_source) \
  VTypedObject* class_name::CreateObject() \
    { return new class_name; } \
  V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
    class_name::CreateObject,plugin_source)

/// \brief
///   Variation of V_IMPLEMENT_DYNCREATE that can be used for classes with pure virtual functions because CreateObject returns null
#define V_IMPLEMENT_DYNCREATE_ABSTRACT(class_name, base_class_name,plugin_source) \
  VTypedObject* class_name::CreateObject() \
    { return NULL; } \
  V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
    class_name::CreateObject,plugin_source)

/// \brief
///   This macro is the cpp counterpart of V_DECLARE_SERIAL. See RTTI documentation for sample code
#define V_IMPLEMENT_SERIAL(class_name, base_class_name, wSchema,plugin_source) \
  VTypedObject* class_name::CreateObject() \
    { return new class_name; } \
  V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
    class_name::CreateObject,plugin_source) \
    VArchive& operator>>( VArchive& ar, class_name* &pObj ) \
    { pObj = (class_name*)ar.ReadObject( V_RUNTIME_CLASS(class_name) ); \
      return ar; } \

/// \brief
///   Variation of V_IMPLEMENT_SERIAL. Can be used for classes with pure virtual functions because CreateObject returns null
#define V_IMPLEMENT_SERIAL_ABSTRACT(class_name, base_class_name, wSchema,plugin_source) \
  VTypedObject* class_name::CreateObject() \
    { return NULL; } \
    V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
    NULL,plugin_source) \
    VArchive& operator>>( VArchive& ar, class_name* &pObj ) \
    { pObj = (class_name*)ar.ReadObject( V_RUNTIME_CLASS(class_name) ); \
    return ar; } \




//Macro for declaring first serializable base object (VTypedObject)
//We don't define operator>> because VArchive does that
//We don't define  CreateObject because you shouldn't create a VTypedObject
#define V_IMPLEMENT_SERIAL_VTYPEDOBJECT(class_name, base_class_name, wSchema,plugin_source) \
  V_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, NULL ,plugin_source)
  
/// \brief
///   Helper macro to create an instance of the passed class name
#define V_CREATE_INSTANCE(class_name)  ((class_name *) V_RUNTIME_CLASS(class_name)->CreateInstance())


#define IsFrom(CLASS_NAME) IsOfType(CLASS_NAME::GetClassTypeId())


class VParamDesc;
struct VModule;


/// \brief
///   Type structure. This is one key class of the RTTI system as it describes class properties
///
/// The base class of a typed class is VTypedObject. To retrieve the type of a class, use VTypedObject::GetTypeId
struct VType
{
// Attributes
public:
  const char* m_lpszClassName;  ///< The class name
  VTypedObject* (*m_pfnCreateObject)(); ///< Creator function; If NULL it refers to an abstract class
  UINT   m_nObjectSize; ///< Internal use
  WORD   m_wSchema;     ///< Internal use
  VType* m_pBaseClass;  ///< The parent class in the hierarchy (or NULL for VTypedObject)

  VModule *m_pModule;                 ///< Pointer to the plugin(dll) this class comes from
  VParamDesc *m_pParamDesc;           ///< For VParamContainer derived classes (not valid during startup)
  VParamDesc *(*GetFullParamDesc)();  ///< For VParamContainer derived classes (not valid during startup)
  VBool      m_bFullParamInit;        ///< Internal use
  VARIABLE_LIST *m_pVarList;          ///< Linked list for all variables of this type
  
  UINT m_iInstances;                  ///< Do not remove. Reserved for later use (number of instances). [FR]
  VType* m_pNextType;                 ///< Linked list implementation

// Operations
public:
  
  VBASE_IMPEXP ~VType();

  /// \brief
  ///   Returns the parent class type.
  VBASE_IMPEXP VType *GetParent() const;

  /// \brief
  ///   Creates an instance of this class type. Does naturally not work for abstract classes.
  VBASE_IMPEXP VTypedObject* CreateInstance();

  /// \brief
  ///   Performs a sanity check on the pointer.
  VBASE_IMPEXP VBool IsBad() const;

  /// \brief
  ///   Indicates whether this type inherits from the passed type.
  VBASE_IMPEXP VBool IsDerivedFrom(const VType *t) const;

  /// \brief
  ///   Change the module that this type is associated with
  VBASE_IMPEXP void SetModule(VModule *pModule);

  /// \brief
  ///   Indicates whether this type is an abstract class (i.e. does not implement CreateInstance()).
  inline VBool IsAbstract() const
  {
    return m_pfnCreateObject==NULL;
  }

  /// \brief
  ///   Indicates whether this type has the VFORGE_HIDECLASS flag set.
  inline VBool IsHidden() const
  {
    return m_pVarList!=NULL && (m_pVarList->m_iVarList_Flags & VFORGE_HIDECLASS)>0;
  }


};


#ifndef _VISION_DOC

struct V_REGISTER_CLASS
{ 
  VBASE_IMPEXP V_REGISTER_CLASS(VType* pType); ///< constructor
};

#endif // _VISION_DOC


/// \brief
///   Enum that stores bitflags for VTypedObject specific flags 
enum VObjectFlags_e
{
  VObjectFlag_None = 0,
  VObjectFlag_BusySerializing               = V_BIT(0),   ///< this flag is set during serialization operations (see VTypedObject::IsBusySerializing)
  VObjectFlag_IsNetworkReplica              = V_BIT(1),   ///< Used by network implementations to mark specific game objects as replica
  VObjectFlag_NetworkObjectExistsRemotely   = V_BIT(2),   ///< Used by network implementations to mark specific game objects as replica
  VObjectFlag_InsideSerializationSession    = V_BIT(4),   ///< This bit is set during saving. vForge sets it for all objects that are going to be included into the serialization session
  VObjectFlag_AutoDispose                   = V_BIT(5),   ///< set this flag so that a scene object (entity, light, ...) is automatically removed from scene (and usually deleted) once the user releases all its own (smart pointer-) references.
  VObjectFlag_Disposed                      = V_BIT(6),   ///< this bit is set when the object is disposed
  VObjectFlag_Disposing                     = V_BIT(7),   ///< disposing is in progress

  VObjectFlag_UserBit0                      = V_BIT(16),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit1                      = V_BIT(17),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit2                      = V_BIT(18),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit3                      = V_BIT(19),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit4                      = V_BIT(20),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit5                      = V_BIT(21),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit6                      = V_BIT(22),  ///< this bit can be used for custom purposes (not used by the engine)
  VObjectFlag_UserBit7                      = V_BIT(23),  ///< this bit can be used for custom purposes (not used by the engine)
};


/// \brief
///   Base class for all classes with RTTI capabilities
class VTypedObject
{
  friend class VArchive;

  V_DECLARE_SERIAL_DLLEXP(VTypedObject, VBASE_IMPEXP)

public:

  /// \brief
  ///   Virtual function to serialize this object. The base implementation does not do anything.
  ///
  /// This function is called by VArchive::ReadObject and VArchive::WriteObject when objects are fully (de-)serialized. Implement this function to read/write
  /// custom object data from/to the archive.
  ///
  /// \param ar
  ///   The archive that serializes this object
  ///
  /// \sa VArchive::ReadObject
  /// \sa VArchive::WriteObject
  /// \sa VTypedObject::OnSerialized
  /// \sa VTypedObject::OnDeserializationCallback
  VBASE_IMPEXP virtual void Serialize(VArchive& ar);

  /// \brief
  ///   Overridable that is called after the serialization of this object has been completed (read and write). Additional object setup can be performed here
  ///
  /// In contrast to OnDeserializationCallback this function is called right after Serialize of one object. The call of OnDeserializationCallback on the other hand
  /// is deferred until the archive is closed and then called on all relevant objects.
  ///
  /// \param ar
  ///   The archive where this object was serialized from
  ///
  /// \sa VTypedObject::Serialize
  /// \sa VTypedObject::OnDeserializationCallback
  VBASE_IMPEXP virtual void OnSerialized(VArchive& ar);

  /// \brief
  ///   You can implement & call this function to do asserts for sanity checks 
  VBASE_IMPEXP virtual void AssertValid();

  /// \brief
  ///   Returns true if this class is the same or derived from the passed type
  VBASE_IMPEXP VBool IsOfType(const VType *type) const;


  /// \brief
  ///   Loops through the hierarchy and returns true if this class is the same
  ///   or derived from the supplied class name.
  VBASE_IMPEXP VBool IsOfType(const char *szClassName) const;

  /// \brief
  ///   Virtual overridable that gets called when the object is created via VType::CreateInstance().
  /// 
  /// The serialization is not completed at that point, so OnDeserializationCallback might be
  /// called instead.
  VBASE_IMPEXP virtual void Initialize();

  /// \brief
  ///   Virtual overridable that notifies an object that it should be removed.
  /// 
  /// When this object is reference counted this function should not necessarily destroy the
  /// object, but at least remove it from all simulation groups.
  /// This function triggers the static OnObjectDisposed callback so application code can listen to all objects being disposed.
  /// 
  /// This base implementation must be called.
  VBASE_IMPEXP virtual void DisposeObject();

  /// \brief
  ///   Indicates whether the object has been disposed already.
  inline bool IsDisposed() const
  {
    return IsObjectFlagSet(VObjectFlag_Disposed);
  }

  /// \brief
  ///   Indicates whether the object is currently being disposed
  inline bool IsDisposing() const
  {
    return IsObjectFlagSet(VObjectFlag_Disposing);
  }

  /// \brief
  ///   Virtual overridable that gets called when a loading archive closes
  /// 
  /// At that point all objects in the serialization session already exist. (This is the difference between this function and overridable VTypedObject::OnSerialized).
  /// Entity classes can use this function to call their virtual InitFunction.
  /// The WantsDeserializationCallback function must also be overridden and return true.
  ///
  /// Please note that the OnDeserializationCallback may also be called a) by vForge when it creates the native instances
  /// and b) by the engine's network manager when an object should be fully replicated. You can specify this when overriding
  /// the VTypedObject::WantsDeserializationCallback method by evaluating the m_eType variable in the passed context
  /// accordingly.
  ///
  /// \param context
  ///   Describes the source of the current deserialization process
  ///
  /// \sa VTypedObject::WantsDeserializationCallback
  /// \sa VTypedObject::OnSerialized
  VBASE_IMPEXP virtual void OnDeserializationCallback(const VSerializationContext &context)
  {
  }

  /// \brief
  ///   Virtual overridable that indicates whether and when OnDeserializationCallback should be called for
  ///   this object
  /// 
  /// The OnDeserializationCallback function is a useful mechanism but it requires that the object
  /// still exists when the archive gets closed.
  /// 
  /// The base implementation returns FALSE as it is not guaranteed that an object survives the
  /// loading process.
  ///
  /// This method also defines whether the OnDeserializationCallback is called when vForge creates an
  /// object instance or the network manager replicates an object. Evaluate the passed context accordingly.
  ///
  /// \param context
  ///   Describes the source of the current deserialization process
  /// 
  /// \return
  ///   TRUE to call OnDeserializationCallback at the end of the deserialization session. The default return value is FALSE
  ///
  /// \sa OnDeserializationCallback
  VBASE_IMPEXP virtual VBool WantsDeserializationCallback(const VSerializationContext &context)
  {
    return FALSE;
  }

  /// \brief
  ///   Overridable that should be implemented for every derived class to add resource dependencies
  ///   via snapshot.AddDependency.
  ///
  /// \param snapshot
  ///   The snapshot object that should be filled with dependency information
  ///
  /// \sa VResourceSnapshot
  VBASE_IMPEXP virtual void GetDependencies(VResourceSnapshot &snapshot) 
  {
  }


  /// \brief
  ///   Sets the specific object flag (not overwriting other flags)
  inline void SetObjectFlag(VObjectFlags_e eFlag)
  {
    m_eObjectFlags |= eFlag;
  }

  /// \brief
  ///   Clears the specific object flag (not overwriting other flags)
  inline void RemoveObjectFlag(VObjectFlags_e eFlag)
  {
    m_eObjectFlags &= (~eFlag);
  }

  /// \brief
  ///   Tests whether the passed bit is set (If multiple bits are passed it tests whether any is set, i.e. the result of logical AND is not null)
  inline bool IsObjectFlagSet(VObjectFlags_e eFlag) const
  {
    return (m_eObjectFlags & eFlag) > 0;
  }

  /// \brief
  ///   Returns the full bitmask
  inline int GetObjectFlags() const
  {
    return m_eObjectFlags;
  }

  /// \brief
  ///   Sets the full bitmask - overwrite the status of all bits
  inline void SetObjectFlags(int iAllFlags)
  {
    m_eObjectFlags = iAllFlags;
  }

  /// \brief
  ///   Indicates whether is object is currently in serialization process
  inline bool IsBusySerializing() const 
  {
    return IsObjectFlagSet(VObjectFlag_BusySerializing);
  }

protected:
    int m_eObjectFlags; ///< Some internal flags (of enum type VObjectFlags_e)

    VType *m_pRegisteredAtType;  ///< Do not remove. Reserved for later use (m_pRegisteredAtType) [FR]

    VBASE_IMPEXP VTypedObject(); ///< Prevents direct instantiation.
    VBASE_IMPEXP virtual ~VTypedObject(); ///< Declares virtual destructor to get the right delete operator if different memory handlers/models are used.

public:
  ///
  /// @name Variable update
  /// @{
  ///

  /// \brief
  ///   Internal function to free memory that has been allocated by variables (e.g. strings).
  ///
  /// This function is called by VTypedObject::DisposeObject
  VBASE_IMPEXP void FreeOwnedData();

  /// \brief
  ///   Return the Type's variable list. Same as GetTypeId()->m_pVarList
  VBASE_IMPEXP VARIABLE_LIST *GetVariableList() const;

  /// \brief
  ///   Overridable to set the a variable value.
  ///
  /// The new variable value is always passed as a string value. Accordingly it has to be parsed if the underlying variable type
  /// is int or float. This base implementation handles this gracefully.
  ///
  /// \param name
  ///   The name of the variable to change
  ///
  /// \param value
  ///   A value string that represents the new variable value.
  ///
  VBASE_IMPEXP virtual bool SetVariable(const char * name, const char * value);

  /// \brief
  ///   Overridable that can be implemented to respond to a variable changing on the object. The base implementation has no effect.
  ///
  /// \param pVar
  ///   The variable that will be changing.
  ///
  /// \param value
  ///   The value that will be set.
  VBASE_IMPEXP virtual VVarChangeRes_e OnVariableValueChanging(VisVariable_cl *pVar, const char * value) { return VCHANGE_IS_ALLOWED; }

  /// \brief
  ///   Overridable that can be implemented to respond to variable changes on the object. The base implementation is empty.
  ///
  /// \param pVar
  ///   The variable that has changed.
  ///
  /// \param value
  ///   The value that has been set.
  VBASE_IMPEXP virtual void OnVariableValueChanged(VisVariable_cl *pVar, const char * value) {}

#if defined(WIN32) || defined(_VISION_DOC)
  
  /// \brief
  ///   Overridable that is called by the editor to retrieve per-instance variable display hints. 
  ///
  /// Implementing this function allow for dynamically show/hide variables in vForge or display in read-only mode.
  /// This function is only relevant in the editor. It is called by the editor when the specific parameter list node is openend 
  /// (e.g. EntityProperties for entity shape) or if a property in the list changes. For these events it is then called for every variable in the list.
  /// Accordingly this feature can be used to display specific variables dependent on the state of other variables. For instance, hide the 'SphereRadius'
  /// variable if 'CollisionType' is set to anything else but 'Sphere'.
  /// Note that this works on a per-instance basis.
  ///
  /// \param pVariable
  ///   Variable to retrieve dynamic display hints for
  ///
  /// \param destInfo
  ///   Structure that can be modified to affect the editor's displaying of the respective variable (read-only, hidden)
  ///
  VBASE_IMPEXP virtual void GetVariableAttributes(VisVariable_cl *pVariable, VVariableAttributeInfo &destInfo) {}

  /// \brief
  ///   Overridable that is called by the editor to temporarily mark instances as part of one serialization session (VObjectFlag_InsideSerializationSession flag)
  VBASE_IMPEXP virtual void SetMarkInsideSerializationSession(bool bStatus)
  {
    if (bStatus)
      SetObjectFlag(VObjectFlag_InsideSerializationSession);
    else
      RemoveObjectFlag(VObjectFlag_InsideSerializationSession);
  }

#endif
  
  /// \brief
  ///   Writes the current variable value into the passed string buffer
  VBASE_IMPEXP virtual bool GetVariableValue(const char* name, char* value) const;

  /// \brief
  ///   Looks up the type's variable by name
  VBASE_IMPEXP VisVariable_cl *GetVariable(const char* name);

  /// \brief
  ///   Returns the number of variables associated with the object's type
  VBASE_IMPEXP int GetNumVariables() const;

  /// \brief
  ///   Returns the name of the n-th variable where iIndex must be [0..GetNumVariables()-1]
  VBASE_IMPEXP const char *GetVariableName(int iIndex) const;

  /// \brief
  ///   Loads the default values for all variables in this object
  VBASE_IMPEXP void InitDefaultValues();


  /// \brief empty base implementation
  static void VTypedObject_BuildVarList(class VARIABLE_LIST* pList) {}
  /// \brief empty base implementation
  static void VTypedObject_DeInitVarList(class VARIABLE_LIST* pList) {}

  /// \brief
  ///   Static callback that is called for every typed object in its VTypedObject::DisposeObject function. The passed data object can be casted to VTypedObjectCallbackData
  static VBASE_IMPEXP VCallback OnObjectDisposed;
  ///
  /// @}
  ///
private:

};

/// \brief
///  Equivalent to a C++ dynamic_cast for objects derived from VTypedObject.
///
/// \param pObject
///   The pointer to be cast.
///
/// \example
///   \code
///     Base* pBase1 = new Base;
///     Base* pBase2 = new Derived;
///     
///     // Result: NULL
///     Derived* pDerived1 = vdynamic_cast<Derived*>(pBase1);
///
///     // Result: pBase2 cast to Derived*
///     Derived* pDerived2 = vdynamic_cast<Derived*>(pBase2);
///   \endcode
///
/// If the dynamic type of the passed object matches the type specified as the first template argument, the result will be a pointer casted to the requested type.
/// Otherwise, NULL is returned.
///
/// Dynamic casts are potentially expensive, so use them only if you rely on detecting the type of an object at runtime. If you know that the object is of the
/// requested type already, use vstatic_cast instead.
///
/// The static type of the passed object must be a base class of the requested type, as this is the only case in which it makes sense to perform a dynamic type
/// hierarchy lookup.
template<typename TargetTypePointer, typename SourceType>
TargetTypePointer vdynamic_cast(SourceType* pObject)
{
  // The type we're casting to should be more derived than the source type - otherwise it doesn't make any sense to cast dynamically. Use a static cast instead.
  typedef typename VTraits::RemovePointer<TargetTypePointer>::type TargetType;
  V_COMPILE_ASSERT((VTraits::IsBaseOf<SourceType, TargetType>::value));
  
  TargetTypePointer pResult = NULL;

  if(pObject != NULL && pObject->IsOfType(TargetType::GetClassTypeId()))
  {
    pResult = static_cast<TargetTypePointer>(pObject);
  }

  // MSVC specific define indicating C++ RTTI presence - use this to check if our own RTTI is correct.
#if defined(_CPPRTTI) && defined(HK_DEBUG)
  VASSERT_MSG(pResult == dynamic_cast<TargetTypePointer>(pObject), "Vision RTTI dynamic cast result differs the from C++ RTTI dynamic cast result - Did you forget to implement the Vision RTTI macros correctly?");
#endif

  return pResult;
}


#if !defined(_VISION_DOC)

  // Overload provided for smart pointer type.
  template<typename Type> class VSmartPtr;

  template<typename TargetTypePointer, typename Type>
  TargetTypePointer vdynamic_cast(const VSmartPtr<Type>& spObject)
  {
    return vdynamic_cast<TargetTypePointer>(spObject.GetPtr());
  }

#endif


/// \brief
///  Equivalent to a C++ static_cast for objects derived from VTypedObject.
///
/// In debug and development builds, vstatic_cast asserts if the dynamic type of the passed object doesn't match the requested type.
/// In release builds, vstatic_cast behaves the same as static_cast.
///
/// \param pObject
///   The pointer to cast.
///
/// \example
///   \code
///     Base* pBase1 = new Base;
///     Base* pBase2 = new Derived;
///     
///     // Assertion!
///     Derived* pDerived1 = vstatic_cast<Derived*>(pBase1);
///
///     // Result: pBase2 cast to Derived*
///     Derived* pDerived2 = vstatic_cast<Derived*>(pBase2);
///   \endcode
template<typename TargetTypePointer>
TargetTypePointer vstatic_cast(VTypedObject* pObject)
{
  typedef typename VTraits::RemovePointer<TargetTypePointer>::type TargetType;

  TargetTypePointer pResult = static_cast<TargetTypePointer>(pObject);
  VASSERT_MSG(pResult == vdynamic_cast<TargetTypePointer>(pObject), "Invalid type conversion");
  return pResult;
}

#ifndef _VISION_DOC

  //class VNull is a workaround so we can have classes with base class NULL
  //(Used only for VTypedObject, since this is the first class in the hierarchy)
  class VNull
  {
  public:
    static int classVNull;
  }; 

#endif // _VISION_DOC

#endif

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
