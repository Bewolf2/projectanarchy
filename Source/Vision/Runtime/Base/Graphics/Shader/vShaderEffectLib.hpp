/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

/// \file vShaderEffectLib.hpp

#ifndef VSHADEREFFECTLIB_HPP_INCLUDED
#define VSHADEREFFECTLIB_HPP_INCLUDED

#include <Vision/Runtime/Base/Graphics/Shader/vShaderIncludes.hpp>
#include <Vision/Runtime/Base/Graphics/Shader/vShaderPassResource.hpp>
#include <Vision/Runtime/Base/Graphics/Shader/vShaderParam.hpp>
#include <Vision/Runtime/Base/Graphics/Shader/vTechniqueConfig.hpp>

#define EFFECTCREATEFLAG_NONE               0x00000000
#define EFFECTCREATEFLAG_FORMODELS          0x00000001
#define EFFECTCREATEFLAG_FORCEUNIQUE        0x00000002
#define EFFECTCREATEFLAG_NOREPORTONFAIL     0x00000004
#define EFFECTCREATEFLAG_NOCONSTANTBUFFER   0x00000100

class VCompiledEffect;

/// \brief
///   Class that represents a single technique in the effect hierarchy as edited in the shader editor.
/// 
/// The technique references shader pass resources that define the shader passes of this technique.
class VShaderEffectTechnique : public VRefCounter, public VUserDataObj
{
public:

  /// \brief
  ///   Constructor, sets defaults
  inline VShaderEffectTechnique()
    : m_ePassType(VPT_AUTO)
    , m_bIsPermutationTechnique(false)
    , m_bIsAutoGenerated(false)
  {
  }

  /// \brief
  ///   Indicates whether the passed platform is supported by this technique (i.e. all shader
  ///   passes in the technique have to support it)
  VBASE_IMPEXP bool SupportsPlatform(VTargetPlatform_e platform=TARGETPLATFORM_THIS) const;

  /// \brief
  ///   Evaluates a bitmask for platforms used in this technique. The bit index per platform corresponds to its enum value in VTargetPlatform_e.
  inline int GetRelevantPlatformMask() const
  {
    int iMask = 0;
    for (int i=0;i<m_Passes.Count();i++)
      iMask |= m_Passes.GetAt(i)->GetSupportedTargetPlatforms ();
    return iMask;
  }

  VString m_sName;                  ///< technique name as set in the shader editor
  VTechniqueConfig m_Config;        ///< technique config with inclusion/exclusion bitflags

  VPassType_e m_ePassType;            ///< enum that defines the pass type of this technique

  VRefCountedCollection<VShaderPassResource> m_Passes; ///< collection of shader pass resource references (as set in the shader editor)

public:
  bool IsPermutationTechnique (void) const { return (m_bIsPermutationTechnique); }
  bool IsAutoGeneratedTechnique (void) const { return (m_bIsAutoGenerated); }
  const VString& GetPermutationConfigFile (void) const { return (m_sPermutationConfigFile); }

  void SetIsPermutationTechnique (bool b) { m_bIsPermutationTechnique = b;}
  void SetIsAutoGenerated (bool b) { m_bIsAutoGenerated = b; }
  void SetPermutationConfigFile (const char* szFile) { m_sPermutationConfigFile = szFile; }

  // Can't make them private, life sucks.
  bool m_bIsPermutationTechnique;   ///< True if this technique is used to create permutations of it.
  bool m_bIsAutoGenerated;          ///< True if this technique was created from a permutation-technique.
  VString m_sPermutationConfigFile; ///< Path to a lua-file that holds the permutation configuration.
};

/// \brief
///   Class that represents a single shader effect resource as edited in the shader editor.
/// 
/// Furthermore, this class provides a cache for compiled versions of this effect.
class VShaderEffectResource : public VRefCounter, public VUserDataObj
{
public:

  ///
  /// @name Constructor/Destructor
  /// @{
  ///

  /// \brief
  ///   Constructor, sets defaults.
  inline VShaderEffectResource(VShaderEffectLib *pOwnerLib) 
  {
    m_pOwnerLib = pOwnerLib;
  }

  /// \brief
  ///   Destructor, sets defaults.
  VBASE_IMPEXP ~VShaderEffectResource();

  /// \brief
  ///   Returns the shader library that this effect resource belongs to.
  inline VShaderEffectLib *GetOwnerEffectLib() const 
  { 
    return m_pOwnerLib; 
  }

  ///
  /// @}
  ///

  ///
  /// @name Build Helpers
  /// @{
  ///


  /// \brief
  ///   Creates a new technique resource attached to this effect.
  VBASE_IMPEXP VShaderEffectTechnique *CreateNewTechnique() 
  { 
    VShaderEffectTechnique *pT = new VShaderEffectTechnique(); 
    m_Techniques.Add(pT); 
    return pT;
  }

  /// \brief
  ///   Evaluates a bitmask for platforms used in this effect. The bit index per platform corresponds to its enum value in VTargetPlatform_e.
  inline int GetRelevantPlatformMask() const
  {
    int iMask = 0;
    for (int i = 0; i < m_Techniques.Count(); i++)
      iMask |= m_Techniques.GetAt(i)->GetRelevantPlatformMask();
    return iMask;
  }

  ///
  /// @}
  ///

  ///
  /// @name Effect Compilation
  /// @{
  ///

#define VISION_DOC_SPACER
#undef VISION_DOC_SPACER

  /// \brief
  ///   Creates a compiled instance of this effect and adds it to the cache.
  /// 
  /// If there is a previously compiled version that used the same parameter string, this
  /// instance will be returned.
  /// 
  /// The effect will try to compile all its techniques.
  /// 
  /// This function is provided through the global Vision::Shaders.CreateEffect function.
  /// 
  /// \param szParamString
  ///   Parameter string with (varname)=(value) pairs that is used to modify the compiled shaders,
  ///   e.g. "Color=1,1,1,0;Glow=0.5;"
  /// 
  /// \param instanceManager
  ///   Shader instance manager that keeps track of new shader instances that are created during
  ///   this process.
  /// 
  /// \param iFlags
  ///   Additional flags for creating the effect. Supported bit constants are:
  ///   \li EFFECTCREATEFLAG_NONE: No specific flags,
  /// 
  ///   \li EFFECTCREATEFLAG_FORMODELS: The vertex shader for models should be used (if available),
  /// 
  ///   \li EFFECTCREATEFLAG_FORCEUNIQUE: If set, both the effect instance and the shader pass instances
  ///     are neither taken from the cache nor re-used for other compiling operations. 
  /// 
  /// \param pLog
  ///   Optional log interface that will receive error/warning/info messages that occur during
  ///   compiling.
  /// 
  /// \return
  ///   BOOL bResult : TRUE if successful.
  VBASE_IMPEXP VCompiledEffect *CompileEffect(const char *szParamString, VCompiledShaderManager &instanceManager, 
    int iFlags=EFFECTCREATEFLAG_NONE, IVLog *pLog=NULL);

  /// \brief
  ///   Helper function to find a compiled effect version that has been generated with the passed
  ///   parameter string.
  /// 
  /// This function performs a simple case-insensitive string match rather than analyzing the actual string parameters.
  /// 
  /// \param szParamString
  ///   Parameter string to find a compiled version for.
  /// 
  /// \return
  ///   VCompiledEffect *pEffect : Compiled instance that has a parameter string corresponding to the passed one. NULL if there is no match.
  VBASE_IMPEXP VCompiledEffect *FindCompiledVersion(const char *szParamString) const;

  /// \brief
  ///   Resets the cache of compiled effect variants.
  VBASE_IMPEXP void FreeCompiledEffects() {m_CachedCompiledVersions.Clear();}

  /// \brief
  ///   Internal function for binary file data exchange (load and save)
  VBASE_IMPEXP void ChunkFileExchange(VChunkFile &file, VTargetPlatform_e targetPlatform);

  /// \brief
  ///   Internal function
  VBASE_IMPEXP void OnDetachFromLib();

  /// \brief
  ///   Adds the inclusion tags given by effect parameters (if any)
  VBASE_IMPEXP void AddEffectParameterInclusionTags(VTechniqueConfig** pConfigs, unsigned int iNumConfigs, const char* const szParamString) const;

  /// \brief
  ///   Returns the name of the effect.
  inline const char* GetName() const
  {
    return m_sName;
  }

public:
  VShaderEffectLib* m_pOwnerLib;
  VString m_sName;
  VString m_sDescription;
  VRefCountedCollection<VShaderEffectTechnique> m_Techniques;
  VShaderParamCollection m_Parameter;

  // temp cache:
  VRefCountedCollection<VCompiledEffect> m_CachedCompiledVersions;
  ///
  /// @}
  ///

};


/// \brief
///   Class that represents a library of shader effects (.ShaderLib file)
class VShaderEffectLib : public VManagedResource, public VUserDataObj
{
public:

  ///
  /// @name Constructor/Destructor
  /// @{
  ///

  /// \brief
  ///   Constructor
  VBASE_IMPEXP VShaderEffectLib(VResourceManager *pManager, const char *szFilename);

  /// \brief
  ///   Resets the library
  VBASE_IMPEXP void Reset();

  ///
  /// @}
  ///

  ///
  /// @name Accessing Resources
  /// @{
  ///

  VArray<VRenderStateContainer*, VRenderStateContainer*> m_RenderStateContainersToWrite;

  int AddRenderStateContainerToWrite (VRenderStateContainer* pRenderState)
  {
    int i = 0;
    for (; i < m_RenderStateContainersToWrite.GetLength (); ++i)
    {
      if (m_RenderStateContainersToWrite[i] == pRenderState)
        return (i);
    }

    m_RenderStateContainersToWrite.Add (pRenderState);
    return (i);
  }

  /// \brief
  ///   Finds a shader resource by shader name.
  /// 
  /// To enumerate all shaders, use the public m_Shaders collection member directly.
  /// 
  /// \param szShaderName
  ///   Shader to find. Name check is case-insensitive.
  /// 
  /// \return
  ///   VShaderPassResource *pShader : Shader resource with specified name. Can be NULL.
  VBASE_IMPEXP VShaderPassResource *FindShader(const char *szShaderName)
  {
    const int iCount = m_Shaders.Count();
    for (int i=0;i<iCount;i++) 
      if (m_Shaders.GetAt(i)->GetName () == szShaderName) 
        return m_Shaders.GetAt(i); 
    return NULL;
  }

  /// \brief
  ///   Finds an effect resource by effect name.
  /// 
  /// To enumerate all effects, use the public m_Effects collection member directly.
  /// 
  /// \param szFXName
  ///   Effect to find. Name check is case-insensitive
  /// 
  /// \return
  ///   VShaderEffectResource *pFX : Effect resource with specified name. Can be NULL.
  VBASE_IMPEXP VShaderEffectResource *FindEffect(const char *szFXName)
  {
    const int iCount = m_Effects.Count();
    for (int i=0;i<iCount;i++) 
      if (m_Effects.GetAt(i)->m_sName==szFXName) 
        return m_Effects.GetAt(i); 
    return NULL;
  }


  ///
  /// @}
  ///

  ///
  /// @name Io
  /// @{
  ///

  /// \brief
  ///   Returns the file version number (200 for version 2.00).
  inline int GetFileVersion() const 
  {
    return m_iFileVersion[0]*100+m_iFileVersion[1];
  }

  /// \brief
  ///   Returns the file version number as separate minor/major version numbers.
  inline void GetFileVersion(int& vmaj, int& vmin) 
  {
    vmaj=m_iFileVersion[0];
    vmin=m_iFileVersion[1];
  }

  /// \brief
  ///   Sets the target platform of this library, e.g. SHADERLIB_PLATFORM_DX9.
  inline void SetPlatform(VTargetPlatform_e ePlatform) 
  {
    m_ePlatform = ePlatform;
  }

  /// \brief
  ///   Gets the target platform of this library, e.g. SHADERLIB_PLATFORM_DX9.
  inline VTargetPlatform_e GetPlatform() const 
  { 
    return m_ePlatform;
  }

  /// \brief
  ///   Evaluates a bitmask for platforms used in this library. Iterates over all effects rather
  ///   than shader list. Each bit is of type 1<<VTargetPlatform_e.
  inline int GetRelevantPlatformMask() const
  {
    int iMask = 0;
    for (int i = 0 ; i < m_Effects.Count(); i++)
      iMask |= m_Effects.GetAt(i)->GetRelevantPlatformMask();
    return iMask;
  }


  ///
  /// @}
  ///

  ///
  /// @name Build Helpers
  /// @{
  ///

  /// \brief
  ///   Returns a new instance of a shader pass resource that is added to this library.
  inline VShaderPassResource *CreateNewShader() 
  { 
    VShaderPassResource *pShader = new VShaderPassResource(this); 
    m_Shaders.Add(pShader); 
    return pShader; 
  }

  /// \brief
  ///   Returns a new instance of an effect resource that is added to this library.
  inline VShaderEffectResource *CreateNewEffect() 
  { 
    VShaderEffectResource *pFX = new VShaderEffectResource(this); 
    m_Effects.Add(pFX);
    return pFX;
  }

  /// \brief
  ///   Returns a new instance of a RenderStateContainer that is added to this library.
  inline VRenderStateContainer *CreateNewRenderStateContainer() 
  { 
    VRenderStateContainer *pFX = new VRenderStateContainer(false); 
    m_RenderStateContainers.Add(pFX); 
    return pFX; 
  }

  /// \brief
  ///   Loops through all effect resources in this library and calls FreeCompiledEffects on each
  VBASE_IMPEXP void FreeCompiledEffects();

  /// \brief
  ///   Internal function for binary file data exchange (loading and saving). Used to load and save .vShaderBin files.
  VBASE_IMPEXP void ChunkFileExchange(VChunkFile &file, VTargetPlatform_e targetPlatform, bool bByteCodeOnly=false);

  /// \brief
  ///   Internal function to load a specific platform version. This function is automatically used
  ///   at runtime outside of the editor.
  VBASE_IMPEXP bool LoadBinaryVersion(VTargetPlatform_e targetPlatform=TARGETPLATFORM_THIS, bool bByteCodeOnly=false, bool bAssertOnError=true);


  ///
  /// @}
  ///

  ///
  /// @name Internal Functions
  /// @{
  ///

  // internal
  VBASE_IMPEXP static void GetPlatformBinaryFilename(const char *szFilename, char *szDest, VTargetPlatform_e targetPlatform);

  /// \brief
  ///   Internal function used during loading.
  inline void SetFileVersion(int vmaj, int vmin) 
  {
    m_iFileVersion[0]=vmaj;
    m_iFileVersion[1]=vmin;
  }

  /// \brief
  ///   Internal function used during loading.
  inline void SetFileVersion(int fullvers)
  {
    SetFileVersion(fullvers/100, fullvers%100);
  }


  ///
  /// @}
  ///

public:
  VBASE_IMPEXP static VString g_sLastError;

  VString m_sSourceCode;
  VRefCountedCollection<VShaderEffectResource> m_Effects;
  VRefCountedCollection<VShaderPassResource> m_Shaders;
  VRefCountedCollection<VRenderStateContainer> m_RenderStateContainers;
  
  bool m_bShow; ///< internal flag, set by the SHADERLIBFLAG_HIDDEN flag when loading the lib
  bool m_bNeedsResave; ///< indicates whether version is outdated
  short m_iLoadingFlags; ///< VShaderCompileFlags_e

protected:
  friend class VShaderPassResource;
#ifdef SUPPORTS_RESOURCE_TIMESTAMP
  VBASE_IMPEXP VOVERRIDE BOOL GatherTimeStamp(IVFileStreamManager *pManager, VFileTime &destTime);
#endif
  VBASE_IMPEXP VOVERRIDE BOOL Reload();
  VBASE_IMPEXP VOVERRIDE BOOL Unload();
  VBASE_IMPEXP VOVERRIDE void AccumulateMemoryFootprint(size_t &iUniqueSys, size_t &iUniqueGPU, 
    size_t &iDependentSys, size_t &iDependentGPU);

public:
  void GetPlatformBinaryFilename(char *szDest, VTargetPlatform_e targetPlatform) const
  {
    GetPlatformBinaryFilename(GetFilename(),szDest,targetPlatform);
  }

  short m_iFileVersion[2];
  VTargetPlatform_e m_ePlatform;

#ifdef WIN32
public:
  const short* GetShaderIndexRemapping (void) const { return (m_pShaderIndexRemapping); }

protected:
  short *m_pShaderIndexRemapping;
#endif

};


#endif

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
