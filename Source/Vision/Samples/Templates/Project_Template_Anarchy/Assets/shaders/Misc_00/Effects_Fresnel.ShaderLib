FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

RENDER_STATE RSC_0 {
  blendingFromSurface = true;
  trackingmask = 1536;
  compiledClass = "VCompiledShaderPass";

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  trackingmask = 1;

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_2 {
  blendingFromSurface = true;
  trackingmask = 1536;
  compiledClass = "VCompiledShaderPass";

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_3 {
  blendingFromSurface = true;
  trackingmask = 1536;
  compiledClass = "VCompiledShaderPass";

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------
  depthwriteenabled = false;

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

SHADER Fresnel_Simple {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Magic.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_UV0
#define USE_EYEDIR


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_UV0
#define USE_EYEDIR




#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Magic.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Magic.dds
			#endif

			#endif





#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 fAlphaTestThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  // use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_0450feb994e246c9af27f44fced65f03 = frac(In.UV0AND1.xy + float2((-1.0 * 0.1 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_0450feb994e246c9af27f44fced65f03 = In.UV0AND1.xy + float2((-1.0 * 0.1 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_0450feb994e246c9af27f44fced65f03
*/
//! MARKER - 3571cee7ee244771b66bfb64ee30651d

/*!float3
In.Normal
*/
//! MARKER - a55b21d4a3334850bc27369213ece2ac
float VAR_d66226c5643a4289a66edf2ee529d607 = saturate( pow( abs(dot(In.Normal, EyeDir)), 2 ));
/*!float
VAR_d66226c5643a4289a66edf2ee529d607
*/
//! MARKER - fe163cbd954747c99ced93a586da5031
#ifdef PREVIEW
			float4 VAR_dc9231847f7a4c0aa4f94faad8b00475 = tex2D( BaseTexture_Sampler, VAR_0450feb994e246c9af27f44fced65f03 );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_dc9231847f7a4c0aa4f94faad8b00475 = BaseTexture.Sample( BaseTexture_Sampler, VAR_0450feb994e246c9af27f44fced65f03 );
			#else
			float4 VAR_dc9231847f7a4c0aa4f94faad8b00475 = tex2D( BaseTexture, VAR_0450feb994e246c9af27f44fced65f03 );
			#endif
			#endif
/*!float
VAR_dc9231847f7a4c0aa4f94faad8b00475.r
*/
/*!float
VAR_dc9231847f7a4c0aa4f94faad8b00475.g
*/
/*!float
VAR_dc9231847f7a4c0aa4f94faad8b00475.b
*/
/*!float
VAR_dc9231847f7a4c0aa4f94faad8b00475.a
*/
/*!float4
VAR_dc9231847f7a4c0aa4f94faad8b00475
*/
//! MARKER - 273e956a12f64e6c91b86416d6f8aeec
float VAR_3e5f830af02140229d02aed225474b72 = (VAR_dc9231847f7a4c0aa4f94faad8b00475.a * VAR_d66226c5643a4289a66edf2ee529d607);
/*!float
VAR_3e5f830af02140229d02aed225474b72
*/
//! MARKER - 3856b0267f394459be9ffca47538a6a7
float4 VAR_3a1024d958744b95b3fea1c841943a41 = float4( VAR_dc9231847f7a4c0aa4f94faad8b00475.r, VAR_dc9231847f7a4c0aa4f94faad8b00475.g, VAR_dc9231847f7a4c0aa4f94faad8b00475.b, VAR_3e5f830af02140229d02aed225474b72 );
/*!float4
VAR_3a1024d958744b95b3fea1c841943a41
*/
//! MARKER - ce9a498975da495ea993b0f5cd318631
return VAR_3a1024d958744b95b3fea1c841943a41;
//! MARKER - 4943bd980ba441e8ac02d328960d2a8f


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER Fresnel_Front {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 2;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Textures\Muster.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  SAMPLER_PS 1 = {
    samplername = "CustomTexture0";
    texturetype = custom;
    textureindex = 0;
    texturefile = "Models\Magic.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_EYEDIR
#define USE_UV0


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_EYEDIR
#define USE_UV0




#ifdef PREVIEW
			
			texture Base_Texture; //TEX Textures\Muster.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Textures\Muster.dds
			#endif

			#endif
#ifdef PREVIEW
			
			texture CustomTexture0; //TEX Models\Magic.dds
			sampler CustomTexture0_Sampler =
			sampler_state
			{
			    Texture = <CustomTexture0>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
	
			#else
			
			#ifdef _VISION_DX11
			
			Texture2D CustomTexture0 : register(t1);
			sampler CustomTexture0_Sampler : register (s1);
			#else
			sampler2D CustomTexture0 : register(s1); //TEX Models\Magic.dds
			#endif
			
			#endif






#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 fAlphaTestThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  
/*!float3
In.Normal
*/
//! MARKER - a55b21d4a3334850bc27369213ece2ac
float VAR_5a646ff51e33445fb41ed0fea243f09d = saturate( pow( abs(dot(In.Normal, EyeDir)), 2 ));
/*!float
VAR_5a646ff51e33445fb41ed0fea243f09d
*/
//! MARKER - fe163cbd954747c99ced93a586da5031
// use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_6eef5b4b703a40d59a503930c539df86 = frac(In.UV0AND1.xy + float2((-1.0 * 0.2 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_6eef5b4b703a40d59a503930c539df86 = In.UV0AND1.xy + float2((-1.0 * 0.2 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_6eef5b4b703a40d59a503930c539df86
*/
//! MARKER - 9c6e3b1287d447d997f182af6ad27024
#ifdef PREVIEW
			float4 VAR_77ff8845c8ac4ece9639ded691963cf0 = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_77ff8845c8ac4ece9639ded691963cf0 = BaseTexture.Sample( BaseTexture_Sampler, In.UV0AND1.xy );
			#else
			float4 VAR_77ff8845c8ac4ece9639ded691963cf0 = tex2D( BaseTexture, In.UV0AND1.xy );
			#endif
			#endif
/*!float
VAR_77ff8845c8ac4ece9639ded691963cf0.r
*/
/*!float
VAR_77ff8845c8ac4ece9639ded691963cf0.g
*/
/*!float
VAR_77ff8845c8ac4ece9639ded691963cf0.b
*/
/*!float
VAR_77ff8845c8ac4ece9639ded691963cf0.a
*/
/*!float4
VAR_77ff8845c8ac4ece9639ded691963cf0
*/
//! MARKER - 817af39aa0484542be22d72341491e1b
#ifdef PREVIEW
			float4 VAR_de32b46e73064db38afdcfb51c69a0aa = tex2D( CustomTexture0_Sampler, VAR_6eef5b4b703a40d59a503930c539df86 );
			#else
				#ifdef _VISION_DX11
				float4 VAR_de32b46e73064db38afdcfb51c69a0aa = CustomTexture0.Sample( CustomTexture0_Sampler, VAR_6eef5b4b703a40d59a503930c539df86 );
				#else
				float4 VAR_de32b46e73064db38afdcfb51c69a0aa = tex2D( CustomTexture0, VAR_6eef5b4b703a40d59a503930c539df86 );
				#endif
			#endif
/*!float
VAR_de32b46e73064db38afdcfb51c69a0aa.r
*/
/*!float
VAR_de32b46e73064db38afdcfb51c69a0aa.g
*/
/*!float
VAR_de32b46e73064db38afdcfb51c69a0aa.b
*/
/*!float
VAR_de32b46e73064db38afdcfb51c69a0aa.a
*/
/*!float4
VAR_de32b46e73064db38afdcfb51c69a0aa
*/
//! MARKER - 16af0f2656f442f58ba4093427df47c8
float VAR_2e122859290e4ee2982d060aa18ce59e = (1.0 - VAR_5a646ff51e33445fb41ed0fea243f09d);
/*!float
VAR_2e122859290e4ee2982d060aa18ce59e
*/
//! MARKER - 5d612bcfb7c34042b33ffdef120e7bbe
float4 VAR_d1e08b5d530c476b8a0542e00c9eda49 = (VAR_de32b46e73064db38afdcfb51c69a0aa * VAR_2e122859290e4ee2982d060aa18ce59e);
/*!float4
VAR_d1e08b5d530c476b8a0542e00c9eda49
*/
//! MARKER - 2c36de522b604514aaa1cc46fa977c15
float4 VAR_5780712d95ff4042a4efa720a8f603fe = float4( VAR_77ff8845c8ac4ece9639ded691963cf0.r, VAR_77ff8845c8ac4ece9639ded691963cf0.g, VAR_77ff8845c8ac4ece9639ded691963cf0.b, (dot(VAR_d1e08b5d530c476b8a0542e00c9eda49.rgba, 0.25)) );
/*!float4
VAR_5780712d95ff4042a4efa720a8f603fe
*/
//! MARKER - 9f73aff4996c45e9bbd31f1d8093adf0
return VAR_5780712d95ff4042a4efa720a8f603fe;
//! MARKER - 4943bd980ba441e8ac02d328960d2a8f


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER Fresnel_Advanced {
  RenderStateContainerID = 2;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Magic.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_UV0
#define USE_EYEDIR


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_UV0
#define USE_EYEDIR











#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Magic.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Magic.dds
			#endif

			#endif














#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 fAlphaTestThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  
/*!float
3
*/
//! MARKER - 6f19bdb298f746cbacc78f86f1dda330

/*!float
0.5
*/
//! MARKER - 92eabf166454477b82c2d801568a7fd2

/*!float
0.25
*/
//! MARKER - ae968b0cb3c34941b446b780e1f7d9c2

/*!float
1
*/
//! MARKER - f7776f9b8a3045fda5ddc1d48f0c6bbd
float VAR_fbe3d1d081dd428e81f5542de6db67ac = gTime.x;
/*!float
VAR_fbe3d1d081dd428e81f5542de6db67ac
*/
//! MARKER - 04cb284487f84f23a53e2cf94da01790
// use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_d18d0948da1c4bdaa4182b5cf01cd413 = frac(In.UV0AND1.xy + float2((-1.0 * -0.2 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_d18d0948da1c4bdaa4182b5cf01cd413 = In.UV0AND1.xy + float2((-1.0 * -0.2 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_d18d0948da1c4bdaa4182b5cf01cd413
*/
//! MARKER - 8dc578f0b16d48ea8f553c8f7b824d63
// use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_bf8bc18372a345efae795decd76e4186 = frac(In.UV0AND1.xy + float2((-1.0 * 0.2 * gTime.x), (-1.0 * 0.2 * gTime.x)));
			#else
			float2 VAR_bf8bc18372a345efae795decd76e4186 = In.UV0AND1.xy + float2((-1.0 * 0.2 * gTime.x), (-1.0 * 0.2 * gTime.x));
			#endif
/*!float2
VAR_bf8bc18372a345efae795decd76e4186
*/
//! MARKER - 5f7d1af766ec44f3bcf70fc37e1b72df

/*!float3
In.Normal
*/
//! MARKER - a55b21d4a3334850bc27369213ece2ac
float VAR_fa40dbbd0be64ec38fb0fc25b11f59f2 = saturate( pow( abs(dot(In.Normal, EyeDir)), 2 ));
/*!float
VAR_fa40dbbd0be64ec38fb0fc25b11f59f2
*/
//! MARKER - fe163cbd954747c99ced93a586da5031

/*!float
2
*/
//! MARKER - 2e1cd4dc499c45b3b35115ff5780bd2a
#ifdef PREVIEW
			float4 VAR_3d9fe0eafb7749e5aa468fa09725fffa = tex2D( BaseTexture_Sampler, VAR_d18d0948da1c4bdaa4182b5cf01cd413 );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_3d9fe0eafb7749e5aa468fa09725fffa = BaseTexture.Sample( BaseTexture_Sampler, VAR_d18d0948da1c4bdaa4182b5cf01cd413 );
			#else
			float4 VAR_3d9fe0eafb7749e5aa468fa09725fffa = tex2D( BaseTexture, VAR_d18d0948da1c4bdaa4182b5cf01cd413 );
			#endif
			#endif
/*!float
VAR_3d9fe0eafb7749e5aa468fa09725fffa.r
*/
/*!float
VAR_3d9fe0eafb7749e5aa468fa09725fffa.g
*/
/*!float
VAR_3d9fe0eafb7749e5aa468fa09725fffa.b
*/
/*!float
VAR_3d9fe0eafb7749e5aa468fa09725fffa.a
*/
/*!float4
VAR_3d9fe0eafb7749e5aa468fa09725fffa
*/
//! MARKER - aec6b2ef1e14472cabada328bce4ccd6
float VAR_e53ab9b270df491bb4306e7343c4ee1e = (VAR_fbe3d1d081dd428e81f5542de6db67ac * 3);
/*!float
VAR_e53ab9b270df491bb4306e7343c4ee1e
*/
//! MARKER - 3f8b89d1521b4c66a087bfb192dc31b2
#ifdef PREVIEW
			float4 VAR_3dbefa0315e1400883542cbafb5acbe0 = tex2D( BaseTexture_Sampler, VAR_bf8bc18372a345efae795decd76e4186 );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_3dbefa0315e1400883542cbafb5acbe0 = BaseTexture.Sample( BaseTexture_Sampler, VAR_bf8bc18372a345efae795decd76e4186 );
			#else
			float4 VAR_3dbefa0315e1400883542cbafb5acbe0 = tex2D( BaseTexture, VAR_bf8bc18372a345efae795decd76e4186 );
			#endif
			#endif
/*!float
VAR_3dbefa0315e1400883542cbafb5acbe0.r
*/
/*!float
VAR_3dbefa0315e1400883542cbafb5acbe0.g
*/
/*!float
VAR_3dbefa0315e1400883542cbafb5acbe0.b
*/
/*!float
VAR_3dbefa0315e1400883542cbafb5acbe0.a
*/
/*!float4
VAR_3dbefa0315e1400883542cbafb5acbe0
*/
//! MARKER - 273e956a12f64e6c91b86416d6f8aeec
float VAR_4e2c64de45774fcba1f4f0d5232e88aa = cos( VAR_e53ab9b270df491bb4306e7343c4ee1e );
/*!float
VAR_4e2c64de45774fcba1f4f0d5232e88aa
*/
//! MARKER - ae69f76a2e6b4e00b0f646241de915f5
float VAR_e535688affff45fdbe661dea5cffba8c = (1.0 - VAR_fa40dbbd0be64ec38fb0fc25b11f59f2);
/*!float
VAR_e535688affff45fdbe661dea5cffba8c
*/
//! MARKER - c9ba017b79044b1b8be0c882c0471a6f
float VAR_5067a06791824f2b975f51f8950935b1 = (VAR_e535688affff45fdbe661dea5cffba8c * 2);
/*!float
VAR_5067a06791824f2b975f51f8950935b1
*/
//! MARKER - 69cebaa2641d4126a5109999efe9e64e
float VAR_0c775681681e47b594003b137cc01589 = (VAR_4e2c64de45774fcba1f4f0d5232e88aa + 1);
/*!float
VAR_0c775681681e47b594003b137cc01589
*/
//! MARKER - c5252557e95d4d2f82c8268a56f3bc0c
float VAR_64c7dea94c6840b5ba1fc719a9d3567e = (VAR_fa40dbbd0be64ec38fb0fc25b11f59f2 * VAR_5067a06791824f2b975f51f8950935b1);
/*!float
VAR_64c7dea94c6840b5ba1fc719a9d3567e
*/
//! MARKER - 317c8c270d6c4950824a44d4e0d1ba15
float VAR_603a3a99297d403fbfb978eeb9c3d5d9 = (VAR_64c7dea94c6840b5ba1fc719a9d3567e * VAR_3d9fe0eafb7749e5aa468fa09725fffa.a);
/*!float
VAR_603a3a99297d403fbfb978eeb9c3d5d9
*/
//! MARKER - 3856b0267f394459be9ffca47538a6a7
float VAR_c6449e44d89a4b3f9140f2b43c8a82a4 = (VAR_0c775681681e47b594003b137cc01589 * 0.25);
/*!float
VAR_c6449e44d89a4b3f9140f2b43c8a82a4
*/
//! MARKER - 14410bf7a8fb42d99e369c6b18abdba7
float VAR_246a9b1c5c1b4ffcb6f079bed18e67d5 = (VAR_c6449e44d89a4b3f9140f2b43c8a82a4 + 0.5);
/*!float
VAR_246a9b1c5c1b4ffcb6f079bed18e67d5
*/
//! MARKER - 851df0d7aebe4a029c9b9b19badcf417
float VAR_69b2f5d78a4c4ab2bd91dbd5e92cd002 = (VAR_603a3a99297d403fbfb978eeb9c3d5d9 * VAR_246a9b1c5c1b4ffcb6f079bed18e67d5);
/*!float
VAR_69b2f5d78a4c4ab2bd91dbd5e92cd002
*/
//! MARKER - 19472be8161442d98031a343fe0bff55
float4 VAR_02b6b4ae0c4048c89b84d6d58a328c3f = float4( VAR_3dbefa0315e1400883542cbafb5acbe0.r, VAR_3dbefa0315e1400883542cbafb5acbe0.g, VAR_3dbefa0315e1400883542cbafb5acbe0.b, VAR_69b2f5d78a4c4ab2bd91dbd5e92cd002 );
/*!float4
VAR_02b6b4ae0c4048c89b84d6d58a328c3f
*/
//! MARKER - ce9a498975da495ea993b0f5cd318631
return VAR_02b6b4ae0c4048c89b84d6d58a328c3f;
//! MARKER - 4943bd980ba441e8ac02d328960d2a8f


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER Lightrays {
  RenderStateContainerID = 3;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 19;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Light.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_UV0
#define USE_EYEDIR


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_UV0
#define USE_EYEDIR









#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Light.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Light.dds
			#endif

			#endif







#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 fAlphaTestThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  
/*!float2
float2(0.5,0.5)
*/
//! MARKER - 36802ffec33b48a89ec2eee047a48d43

/*!float
3.141593
*/
//! MARKER - 14ae0fdc37434ee7b688deb50943ee74
float VAR_ed2810c98c3a42828e383bb3f0b29247 = sin( 3.141593 );
			float VAR_0acbc41d044e43438335de66d5a1a31a = cos( 3.141593 );
			float2 VAR_69fdd88eed4d4810bc02c5c409e5d6b7 = float2( ((In.UV0AND1.xy.x-float2(0.5,0.5).x) * VAR_0acbc41d044e43438335de66d5a1a31a) - ((In.UV0AND1.xy.y-float2(0.5,0.5).y) * VAR_ed2810c98c3a42828e383bb3f0b29247), ((In.UV0AND1.xy.y-float2(0.5,0.5).y) * VAR_0acbc41d044e43438335de66d5a1a31a) + ((In.UV0AND1.xy.x-float2(0.5,0.5).x) * VAR_ed2810c98c3a42828e383bb3f0b29247) ) + float2( float2(0.5,0.5) );
/*!float2
VAR_69fdd88eed4d4810bc02c5c409e5d6b7
*/
//! MARKER - 400df3446c1945a88c868e997bf8c875
// use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_d919827f2e114876ac1ebc6d9de600bb = frac(VAR_69fdd88eed4d4810bc02c5c409e5d6b7 + float2((-1.0 * 0.005 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_d919827f2e114876ac1ebc6d9de600bb = VAR_69fdd88eed4d4810bc02c5c409e5d6b7 + float2((-1.0 * 0.005 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_d919827f2e114876ac1ebc6d9de600bb
*/
//! MARKER - 8dc578f0b16d48ea8f553c8f7b824d63

/*!float
2
*/
//! MARKER - 90871fd81f794e6785c65585a4528e29
// use another fragment for preview purposes
			#ifdef PREVIEW
			float2 VAR_23c1becdfa1c483d9e89db5f1c5342f5 = frac(In.UV0AND1.xy + float2((-1.0 * 0.005 * gTime.x), (-1.0 * 0 * gTime.x)));
			#else
			float2 VAR_23c1becdfa1c483d9e89db5f1c5342f5 = In.UV0AND1.xy + float2((-1.0 * 0.005 * gTime.x), (-1.0 * 0 * gTime.x));
			#endif
/*!float2
VAR_23c1becdfa1c483d9e89db5f1c5342f5
*/
//! MARKER - 5f7d1af766ec44f3bcf70fc37e1b72df

/*!float3
In.Normal
*/
//! MARKER - a55b21d4a3334850bc27369213ece2ac
float VAR_66113d29b65a4cc990f868d7c27fe5b6 = saturate( pow( abs(dot(In.Normal, EyeDir)), 1 ));
/*!float
VAR_66113d29b65a4cc990f868d7c27fe5b6
*/
//! MARKER - fe163cbd954747c99ced93a586da5031
#ifdef PREVIEW
			float4 VAR_cca0c7eb4dd5455cb3532c430767001f = tex2D( BaseTexture_Sampler, VAR_d919827f2e114876ac1ebc6d9de600bb );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_cca0c7eb4dd5455cb3532c430767001f = BaseTexture.Sample( BaseTexture_Sampler, VAR_d919827f2e114876ac1ebc6d9de600bb );
			#else
			float4 VAR_cca0c7eb4dd5455cb3532c430767001f = tex2D( BaseTexture, VAR_d919827f2e114876ac1ebc6d9de600bb );
			#endif
			#endif
/*!float
VAR_cca0c7eb4dd5455cb3532c430767001f.r
*/
/*!float
VAR_cca0c7eb4dd5455cb3532c430767001f.g
*/
/*!float
VAR_cca0c7eb4dd5455cb3532c430767001f.b
*/
/*!float
VAR_cca0c7eb4dd5455cb3532c430767001f.a
*/
/*!float4
VAR_cca0c7eb4dd5455cb3532c430767001f
*/
//! MARKER - aec6b2ef1e14472cabada328bce4ccd6
float VAR_e04c511023b94a71bf9b6905079261cd = (VAR_66113d29b65a4cc990f868d7c27fe5b6 * VAR_cca0c7eb4dd5455cb3532c430767001f.a);
/*!float
VAR_e04c511023b94a71bf9b6905079261cd
*/
//! MARKER - 3856b0267f394459be9ffca47538a6a7
#ifdef PREVIEW
			float4 VAR_a8cd674d56b045289fd4871f6e8da399 = tex2D( BaseTexture_Sampler, VAR_23c1becdfa1c483d9e89db5f1c5342f5 );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_a8cd674d56b045289fd4871f6e8da399 = BaseTexture.Sample( BaseTexture_Sampler, VAR_23c1becdfa1c483d9e89db5f1c5342f5 );
			#else
			float4 VAR_a8cd674d56b045289fd4871f6e8da399 = tex2D( BaseTexture, VAR_23c1becdfa1c483d9e89db5f1c5342f5 );
			#endif
			#endif
/*!float
VAR_a8cd674d56b045289fd4871f6e8da399.r
*/
/*!float
VAR_a8cd674d56b045289fd4871f6e8da399.g
*/
/*!float
VAR_a8cd674d56b045289fd4871f6e8da399.b
*/
/*!float
VAR_a8cd674d56b045289fd4871f6e8da399.a
*/
/*!float4
VAR_a8cd674d56b045289fd4871f6e8da399
*/
//! MARKER - 273e956a12f64e6c91b86416d6f8aeec
float VAR_2c694562b7794c8d9619ae2d9ee00b3e = (VAR_e04c511023b94a71bf9b6905079261cd * 2);
/*!float
VAR_2c694562b7794c8d9619ae2d9ee00b3e
*/
//! MARKER - 3b9a0c379b4e4764bd128f9463ac5306
float VAR_2475fb6e08884cc79d09e6fd4f131e34 = (VAR_a8cd674d56b045289fd4871f6e8da399.a * VAR_2c694562b7794c8d9619ae2d9ee00b3e);
/*!float
VAR_2475fb6e08884cc79d09e6fd4f131e34
*/
//! MARKER - 19472be8161442d98031a343fe0bff55
float4 VAR_7c2c1d8fdd8744b5b9d7b26a69cb73c8 = float4( VAR_a8cd674d56b045289fd4871f6e8da399.r, VAR_a8cd674d56b045289fd4871f6e8da399.g, VAR_a8cd674d56b045289fd4871f6e8da399.b, VAR_2475fb6e08884cc79d09e6fd4f131e34 );
/*!float4
VAR_7c2c1d8fdd8744b5b9d7b26a69cb73c8
*/
//! MARKER - ce9a498975da495ea993b0f5cd318631
return VAR_7c2c1d8fdd8744b5b9d7b26a69cb73c8;
//! MARKER - 4943bd980ba441e8ac02d328960d2a8f


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT Fresnel_Simple {
  DESCRIPTION = {};
  TECHNIQUE "Fresnel_Simple"
  {
    passes="Fresnel_Simple";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT Fresnel_Advanced {
  DESCRIPTION = {};
  TECHNIQUE "Fresnel_Advanced"
  {
    inclusionTags="HWSPANNING";
    passes="Fresnel_Advanced";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT Lightrays {
  DESCRIPTION = {};
  TECHNIQUE "Lightrays"
  {
    passes="Lightrays";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

