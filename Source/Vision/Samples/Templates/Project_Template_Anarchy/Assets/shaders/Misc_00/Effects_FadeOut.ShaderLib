FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

RENDER_STATE RSC_0 {
  blendingFromSurface = true;
  trackingmask = 1536;
  compiledClass = "VCompiledShaderPass";

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  blendingFromSurface = true;
  trackingmask = 1536;
  compiledClass = "VCompiledShaderPass";

  //------ Blend State Group ------
  alphatestref = 100;
  alphatestfunc = less_or_equal;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------
  cullmode = none;

  //------ Tesselation State Group ------
}

SHADER FadeOut_Simple {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Star_03.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_UV0


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_UV0

#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Star_03.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Star_03.dds
			#endif

			#endif







#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 fAlphaTestThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  #ifdef PREVIEW
			float4 VAR_beb5a26bf6894324b3b720175eae332d = tex2D( BaseTexture_Sampler, In.UV0AND1.xy );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_beb5a26bf6894324b3b720175eae332d = BaseTexture.Sample( BaseTexture_Sampler, In.UV0AND1.xy );
			#else
			float4 VAR_beb5a26bf6894324b3b720175eae332d = tex2D( BaseTexture, In.UV0AND1.xy );
			#endif
			#endif
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.r
*/
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.g
*/
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.b
*/
/*!float
VAR_beb5a26bf6894324b3b720175eae332d.a
*/
/*!float4
VAR_beb5a26bf6894324b3b720175eae332d
*/
//! MARKER - 2d8b9edf279b4b75b99985f3281858ec
float VAR_c797003c60694dbdb420a3b7f5eb99af = gTime.x;
/*!float
VAR_c797003c60694dbdb420a3b7f5eb99af
*/
//! MARKER - b76167cc4cf544959d708a66c0fa5cda
float VAR_14057341f85d47acb2a8e332d9b81268 = sin( VAR_c797003c60694dbdb420a3b7f5eb99af );
/*!float
VAR_14057341f85d47acb2a8e332d9b81268
*/
//! MARKER - f38107f659e34f51af3bb51a958423e4
float VAR_0916b42e04cf433bbb50807cc5e8a1a3 = (VAR_beb5a26bf6894324b3b720175eae332d.a * VAR_14057341f85d47acb2a8e332d9b81268);
/*!float
VAR_0916b42e04cf433bbb50807cc5e8a1a3
*/
//! MARKER - 8af74baba5c24939a4cfa6aa8f5a2d22
float4 VAR_73464cc535294d299ad64b0b0172626d = float4( VAR_beb5a26bf6894324b3b720175eae332d.r, VAR_beb5a26bf6894324b3b720175eae332d.g, VAR_beb5a26bf6894324b3b720175eae332d.b, VAR_0916b42e04cf433bbb50807cc5e8a1a3 );
/*!float4
VAR_73464cc535294d299ad64b0b0172626d
*/
//! MARKER - 7622e6b5479842d98c4254c769b37393
return VAR_73464cc535294d299ad64b0b0172626d;
//! MARKER - 864fb4e331f445c1bfa6fe6c281059de


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER FadeOut_Advanced {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 1;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "Base_Texture";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "Models\Textures\Star_03.dds";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 1;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

#define USE_UV0


//- PERMUTATION MARKER -\\

#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined(DEFERRED_RENDERING)
	#define USE_TANGENT
	#undef USE_LIGHT_WS
#endif

#ifdef _VISION_DX11

cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 fClipPlanes : packoffset(c12);
  float4    eyePos          : packoffset(c17);  // eye position
  float4    fogParamVS        : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
}

cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4  mMV   : packoffset(c0);   // model view matrix
  float4x4  mMVP  : packoffset(c4);   // model view projection matrix
  float4x4  mMW : packoffset(c8);   // model to worldspace matrix
  float4    LightmapScaleOfs : packoffset(c13);  // model UV to lightmap
}

cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float4 LightPos : packoffset(c0);
  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
    float4 RefPlaneX : packoffset(c1);
    float4 RefPlaneY : packoffset(c2);
    float4 RefPlaneW : packoffset(c3);
  #endif
}

#else

	float4x4 mMV : register(c0);
	float4x4 mMVP : register(c8);
	float4x4 mMW : register(c20);
	float3 eyePos : register(c31);

	float4 fClipPlanes : register(c24);

	#ifdef _VISION_PS3
	  float4 LightPos : register(c64);
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX : register(c66);
	    float4 RefPlaneY : register(c67);
	    float4 RefPlaneW : register(c68);
	  #endif
	#else
	  float4 LightPos;
	  #if defined(PERMUTATION_SpotLight) || defined(PERMUTATION_ProjPointLight)
	    float4 RefPlaneX;
	    float4 RefPlaneY;
	    float4 RefPlaneW;
	  #endif
	#endif

	float4 LightmapScaleOfs : register(c60);
	#ifdef USE_FOGCOORD
	float4 fogParamVS : register(c62);
	#endif
	
#endif

#ifdef DEFERRED_RENDERING
float3 GetVectorInTextureSpace(float3 InVector, float3 Tangent, float3 Normal, float3 BiNormal)
{
  float3 OutVector;

  OutVector.x = dot (Tangent, InVector);
  OutVector.y = -dot (BiNormal, InVector);
  OutVector.z = dot (Normal, InVector);
  return OutVector;
}
#endif

struct VS_IN                   
{                              
  float3 ObjPos   : POSITION;
  float3 Normal : NORMAL;
  
  #ifdef USE_COLOR
  float4 Color : COLOR0;
  #endif  
  
  #ifdef USE_UV0
  float2 UV0 : TEXCOORD0;
  #endif
  
  #ifdef USE_UV1
  float2 UV1 : TEXCOORD1;
  #endif

#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
#endif
};                                           

struct VS_OUT                                 
{                           
#ifdef _VISION_DX11
	float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif

#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif

#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION) || defined(USE_EYEDIR)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif

  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif

#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};                                             

VS_OUT vs_main( VS_IN In )                        
{                                              
  VS_OUT Out = (VS_OUT)0; 

  float3 objectSpaceNormal = In.Normal;
  float4 objectSpacePos = float4(In.ObjPos, 1.0f);
  float3 worldPos = mul(mMW, objectSpacePos);
  
  #ifdef USE_TANGENT
    float3 objectSpaceTangent = In.Tangent;
  #endif

  #if defined( USE_WORLD_POSITION ) || defined( USE_EYEDIR )
    Out.fogCoordAndWorldPos.xyz = worldPos;
  #endif  
  
  Out.ProjPos = mul(mMVP, float4(In.ObjPos, 1.0f));  
  Out.ScreenPosition = float4(Out.ProjPos.xy, Out.ProjPos.z, Out.ProjPos.w);

#ifdef USE_UV0  
Out.UV0AND1.x = In.UV0.x;
Out.UV0AND1.y = In.UV0.y;
#endif
  
  #ifdef USE_COLOR
  Out.Color = In.Color;
  #endif
  
#ifdef USE_UV1  
Out.UV0AND1.zw = In.UV1.xy * LightmapScaleOfs.xy+LightmapScaleOfs.zw;
#endif
  
  //output normal, tangent and bi-tangent in worldspace
  Out.Normal  = normalize( mul((float3x3)mMW , objectSpaceNormal) );
  
#ifdef USE_TANGENT
  Out.Tangent = normalize( mul((float3x3)mMW , objectSpaceTangent) );
  float fMul = dot(objectSpaceTangent, objectSpaceTangent) - 2.0f;
  Out.BiTangent = normalize( cross(Out.Tangent, Out.Normal)*fMul );
#endif

#ifdef USE_FOGCOORD
  Out.fogCoordAndWorldPos.w = (Out.ProjPos.z-fogParamVS.x) * fogParamVS.z;
#endif

#ifdef USE_LIGHT_WS
  Out.LightWS = LightPos.xyz - worldPos;
#endif

  #ifdef PERMUTATION_ProjPointLight
    //Out.ProjDir = mul( mLight, Out.LightWS);
    // rather use existing matrix (same for spotlights):
    Out.ProjDir.x = dot(Out.LightWS,RefPlaneX.xyz);
    Out.ProjDir.y = dot(Out.LightWS,RefPlaneY.xyz);
    Out.ProjDir.z = dot(Out.LightWS,RefPlaneW.xyz);
  #endif
  #ifdef PERMUTATION_SpotLight
    //Compute projected texture coordinate
    Out.ProjTexCoord.x = dot(RefPlaneX, float4(worldPos,1.0));
    Out.ProjTexCoord.y = dot(RefPlaneY, float4(worldPos,1.0));
    Out.ProjTexCoord.z = 0.0f;
    Out.ProjTexCoord.w = dot(RefPlaneW, float4(worldPos,1.0));
    float4 bias = Out.ProjTexCoord.w*float4(0.5f, 0.5f, 0.0f, 0.0f);
    Out.ProjTexCoord += bias;
  #endif
  
  #ifdef DEFERRED_RENDERING
  float4 worldSpacePos = mul(mMW, float4(In.ObjPos, 1.0f));
  Out.EyeDirAndDepth.xyz = GetVectorInTextureSpace(eyePos-worldSpacePos.xyz, Out.Tangent, Out.Normal, Out.BiTangent);
  Out.EyeDirAndDepth.w = mul(mMV, float4(In.ObjPos, 1.0f)).z / fClipPlanes.y;  
  #endif

  return Out;                              
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_3_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_3_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
// generated code by the visual shader editor
// Visual Shader Editor by Trinigy

//- PERMUTATION MARKER -\\

#define USE_UV0





#ifdef PREVIEW
			
			texture Base_Texture; //TEX Models\Textures\Star_03.dds
			sampler BaseTexture_Sampler = 
			sampler_state
			{
			    Texture = <Base_Texture>;
				MinFilter = Anisotropic;
				MagFilter = Linear;
				MaxAnisotropy = 4;
			};
			#else
			
			#ifdef _VISION_DX11
			Texture2D   BaseTexture         : register(t0);
			sampler     BaseTexture_Sampler  : register(s0);			
			#else
			sampler2D BaseTexture : register(s0); //TEX Models\Textures\Star_03.dds
			#endif

			#endif











#if defined(PERMUTATION_PointLight)
	#define USE_LIGHT_WS
#endif

#if defined( USE_EYEDIR ) && !defined(USE_WORLD_POSITION)
	#define USE_WORLD_POSITION
#endif

#ifdef _VISION_DX11
	cbuffer g_GlobalConstantBufferUser : register (b2)
	{
	  float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias. Same as for Material itself!
	  float4 LightRadius; // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	  
    #ifndef DEFERRED_RENDERING
    float4 LightColor; // xyz: color with pre-multiplied light multiplier
    #else
	  float AlphaThreshold;
    #endif
    
    float  GlobalAmbientMultiplier;
    
    
	}
	
  cbuffer g_GlobalConstantBufferLightGrid : register (b3)
  {
    float4      Light0           : packoffset(c0);
    float4      Light1           : packoffset(c1);
    float4      Light2           : packoffset(c2);
    float4      Light3           : packoffset(c3);
    float4      Light4           : packoffset(c4);
    float4      Light5           : packoffset(c5);
  }	
  
  cbuffer g_GlobalConstantBufferFrame : register (b0)
  {
    float     gTime : packoffset(c16);
    float4    gCamPos : packoffset(c17);
    float4    gCamDir : packoffset(c18);
    float4    depthFogCol     : packoffset(c20);  // linear depth fog color
    float4    gGlobalAmbient : packoffset(c21);
    float4    LightmapMultiplier     : packoffset(c22);  // lightmap multiplier (scalar)
  }  
  
#else

float4 LightmapMultiplier : register(c0);

#ifdef USE_FOGCOORD
float4 gFogColor : register(c1);
#endif

	float4 Light0 : register(c26);
	float4 Light1 : register(c27);
	float4 Light2 : register(c28);
	float4 Light3 : register(c29);
	float4 Light4 : register(c30);
	float4 Light5 : register(c31);

	float2 gTime : register(c18);
	float4 gCamPos : register(c19);
	float4 gCamDir : register(c20);
	float4 gGlobalAmbient : register(c21);

	#ifdef _VISION_PS3
	float4 MaterialParams : register(c32);
	float4 LightPos : register(c64);
	float4 LightColor:register(c33);
	float4 LightRadius:register(c34);
	#else
	float4 MaterialParams; // x:specular mul, y:specular exp, z=Parallax Scaling, w=Parallax Bias.
	float4 LightPos;
	float4 LightRadius;    // x:Radius, y:1/Radius (used for attenuation texture), z:Radius^2(not used), w:1/Radius^2(not used)
	float4 LightColor;     // xyz: color with pre-multiplied light multiplier
	#endif

	#ifdef DEFERRED_RENDERING
	float4 fAlphaTestThreshold : register(c34);
	float  GlobalAmbientMultiplier : register(c35);
	#undef USE_LIGHT_WS // for security only
	#endif

#endif

// Here are the light functions
#ifdef LIGHTING_FUNCTIONS

	struct LIGHT_RESULT_SPEC
	{
	  float4 diffuse;
	  float4 specular;
	};

	//Computes the lightgrid diffuse+specular for a worldspace normal
	LIGHT_RESULT_SPEC GetLightGridSpec_WS(float3 eyeDir, float3 normal, 
	                                      float4 Light0, float4 Light1, 
	                                      float4 Light2, float4 Light3, 
	                                      float4 Light4, float4 Light5, 
	                                      float specExp)
	{
	  LIGHT_RESULT_SPEC lsres;
	  
	  float3 w = normal*normal;
	  
	  float3 vHalfAngleX,vHalfAngleY,vHalfAngleZ;
	  float4 cDiffuseX,cDiffuseY,cDiffuseZ;
	  
	  if (normal.x>0.0f)
	  {
	    vHalfAngleX = eyeDir + float3(1,0,0);
	    cDiffuseX = Light0;
	  } 
	  else
	  {
	    vHalfAngleX = eyeDir - float3(1,0,0);
	    cDiffuseX = Light1;
	  }
	  
	  if (normal.y>0.0f)
	  {
	    vHalfAngleY = eyeDir + float3(0,1,0);
	    cDiffuseY = Light2;
	  } 
	  else
	  {
	    vHalfAngleY = eyeDir - float3(0,1,0);
	    cDiffuseY = Light3;
	  }
	  
	  if (normal.z>0.0f)
	  {
	    vHalfAngleZ = eyeDir + float3(0,0,1);
	    cDiffuseZ = Light4;
	  } 
	  else
	  {
	    vHalfAngleZ = eyeDir - float3(0,0,1);
	    cDiffuseZ = Light5;
	  }


	  //Compute the specular
	  float3 vSpec;
	  vSpec.x = dot(normalize(vHalfAngleX), normal);
	  vSpec.y = dot(normalize(vHalfAngleY), normal);
	  vSpec.z = dot(normalize(vHalfAngleZ), normal);
	  
	  vSpec = pow( max(vSpec, 0.0), specExp) ;
	  
	  cDiffuseX *= w.x;
	  cDiffuseY *= w.y;
	  cDiffuseZ *= w.z;
	  
	  lsres.diffuse  = cDiffuseX          +  cDiffuseY         + cDiffuseZ;
	  lsres.specular = cDiffuseX*vSpec.x  +  cDiffuseY*vSpec.y + cDiffuseZ*vSpec.z;

	  return lsres;
	}
	
	LIGHT_RESULT_SPEC ComputeDot3LightmapLightingSpec(float3 normal, float3 lightDir, float3 eyeDir, float4 lightContrib, float specExp)
	{
	  LIGHT_RESULT_SPEC Out;
	  float fDot, fSDot;
	  float3 halfAngle;
	  fDot = max(dot(normal, lightDir) , 0.0);
	  Out.diffuse = lightContrib * fDot;
	  halfAngle = normalize(eyeDir + lightDir);
	  fSDot = dot(halfAngle, normal);
	  fSDot = pow(max(fSDot,0.0), specExp);
	  Out.specular = lightContrib * fSDot * fDot;
	  return Out;
	}	
	
	//Note: HalfAngle and Normal should be in the same space
	float GetSpecularIlluminationPoint(float3 HalfAngle, float3 Normal, float Exp)
	{
	    float SpecProd;
	    float3 nrmHalfAngleVec = normalize(HalfAngle);
	    SpecProd = dot(nrmHalfAngleVec, Normal);
	    SpecProd = pow(SpecProd, Exp);
	    return SpecProd;
	}	

	float4 Lighting_LightGrid( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeNorm )
	{
		LIGHT_RESULT_SPEC res = GetLightGridSpec_WS(EyeNorm, Normal, 
                                       Light0, Light1, 
                                       Light2, Light3, 
                                       Light4, Light5, 
                                       SpecularExponent);

		float4 result = res.diffuse*DiffuseColor;
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		
		result += res.specular*SpecMul;
		
		result.a = Opacity;
		
		return result;
	}
	
	#ifdef PERMUTATION_PointLight
	
	float4 Lighting_PointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 LightWS, float3 WorldPosition )
	{
	
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture
		#endif

  
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		
		float DotProd = saturate(dot(NormLightVec, Normal));
		
    	float4 ResColor = DiffuseColor * LightInt * LightColor * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint( normalize(gCamPos-WorldPosition) + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));		
	
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_LightmapDot3
	
	float4 Lighting_LightmapDot3( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float2 LightmapCoord )
	{
		const float3 vLightDir1 = float3(-0.816497, -0.000000, 0.577350);
		const float3 vLightDir2 = float3(0.408248,  -0.707107, 0.577350);
		const float3 vLightDir3 = float3(0.408248,   0.707107, 0.577350);
		
		#ifdef _VISION_DX11
		float4 cLightmap1 = Lightmap1.Sample(Lightmap1_Sampler, LightmapCoord);
		float4 cLightmap2 = Lightmap2.Sample(Lightmap2_Sampler, LightmapCoord);
		float4 cLightmap3 = Lightmap3.Sample(Lightmap3_Sampler, LightmapCoord);
		#else
		float4 cLightmap1 = tex2D(Lightmap1, LightmapCoord);
		float4 cLightmap2 = tex2D(Lightmap2, LightmapCoord);
		float4 cLightmap3 = tex2D(Lightmap3, LightmapCoord);
		#endif
		
		LIGHT_RESULT_SPEC lsres;
		LIGHT_RESULT_SPEC difspec;

		difspec = ComputeDot3LightmapLightingSpec(Normal, vLightDir1, EyeDir, cLightmap1, SpecularExponent);

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir2, EyeDir, cLightmap2, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		lsres = ComputeDot3LightmapLightingSpec(Normal, vLightDir3, EyeDir, cLightmap3, SpecularExponent);
		difspec.diffuse  += lsres.diffuse;
		difspec.specular += lsres.specular;

		float4 cResColor = difspec.diffuse*DiffuseColor*LightmapMultiplier.x;
 
		//modulate the specular lighting (either by color or float)
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
    SpecMul *= SpecularMultiplier;
		cResColor += difspec.specular*SpecMul;
		cResColor.a = Opacity;
		
		return cResColor;
	}
	
	#endif
	
	#ifdef PERMUTATION_SpotLight
	
	float4 Lighting_Spotlight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float4 ProjTexCoord )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif
		
		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjTexCoord / ProjTexCoord.w); //2D spotlight projector
		#else
		float4 ProjLightCol = LightColor*tex2Dproj(ProjTex, ProjTexCoord); //2D spotlight projector
		#endif

		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		   
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
	
		ResColor += (SpecMul * SpecProd * float4(ProjLightCol.rgb, 0.0));
		ResColor*=saturate(sign(ProjTexCoord.w));
		
		return float4(ResColor.rgb, Opacity);
	}
	
	#endif
	
	#ifdef PERMUTATION_ProjPointLight

	float4 Lighting_ProjPointLight( float4 DiffuseColor, float3 Normal, float SpecularExponent, float3 SpecularColor, float SpecularMultiplier, float3 AmbientColor, float Opacity, float3 EyeDir, float3 LightWS, float3 ProjDir )
	{
		float LightIntR = length(LightWS.xyz) * LightRadius.y;  // dist 0..1 for 0..r. Let the sampler clamp it to [0..1], not the shader
		
		#ifdef _VISION_DX11
		float LightInt = AttenTex.Sample(AttenTex_Sampler, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#else
		float LightInt = tex2D(AttenTex, float2(LightIntR, 0.0f)).x; //custom attenuation curve texture		
		#endif

		#ifdef _VISION_DX11
		float4 ProjLightCol = LightColor*ProjTex.Sample(ProjTex_Sampler, ProjDir); // Cubemap projector
		#else
		float4 ProjLightCol = LightColor*texCUBE(ProjTex, ProjDir); // Cubemap projector
		#endif
		
		float3 NormLightVec = normalize(LightWS);
		float4 SpecMul = float4(SpecularColor.rgb, 1.0);
		float DotProd = saturate(dot(NormLightVec.xyz, Normal));

		float4 ResColor = DiffuseColor * LightInt * ProjLightCol * DotProd;
		
		float SpecProd = GetSpecularIlluminationPoint(EyeDir + NormLightVec, Normal, SpecularExponent);
    SpecProd *= SpecularMultiplier;
		SpecProd = saturate(SpecProd * LightInt * DotProd);
		ResColor += (SpecMul * SpecProd * float4(LightColor.rgb, 0.0));	
	
		return float4(ResColor.rgb, Opacity);	
	}
	
	#endif
	
#endif

#ifdef DEFERRED_RENDERING

struct PixelDataPacked
{
  float4 Accumulation;
  float4 Diffuse;
  float4 Normal;
  float4 DepthSpec;
};

struct PixelDataUnpacked
{
  float3 vAccInitial;
  float fDepth;
  float3 vNormal;
  float3 vDiffColor;
  float3 vSpecColor;
  float fSpecExp;
};



#ifdef _VISION_XENON

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.125f, ip);
  uncompressedComponents.g = modf(ip * 0.125f, ip);
  uncompressedComponents.r = ip * 0.125f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 7.0f);
  return truncated.r * 64.f + truncated.g * 8.f + truncated.b;
}

#else

float3 expandFloatToFloat3_16Bits(float compressedFloat)
{ 
  float ip;
  float3 uncompressedComponents;
  uncompressedComponents.b = modf(compressedFloat * 0.0625f, ip);
  uncompressedComponents.g = modf(ip * 0.0625f, ip);
  uncompressedComponents.r = ip * 0.0625f;
  return uncompressedComponents;
} 

float compressFloat3ToFloat_16Bits(float3 originalValue)
{
  float3 truncated = trunc(originalValue * 15.0f);
  return truncated.r * 256.f + truncated.g * 16.f + truncated.b;
}

#endif

struct DEFERRED_OUT
{
#ifdef _VISION_DX11
  float4 Accumulation : SV_Target0;
  float4 Diffuse : SV_Target1;
  float4 Normal : SV_Target2;
  float4 DepthSpec : SV_Target3;

#else
  float4 Accumulation : COLOR0;
  float4 Diffuse : COLOR1;
  float4 Normal : COLOR2;
  float4 DepthSpec : COLOR3;
 #endif
};

inline DEFERRED_OUT packPixelValues(PixelDataUnpacked pixelData)
{
  DEFERRED_OUT Out;
  Out.Accumulation = float4(pixelData.vAccInitial, 1.0f);
  Out.Diffuse = float4(pixelData.vDiffColor, pixelData.fSpecExp);
  Out.Normal = float4(pixelData.vNormal*0.5f + 0.5f, 1.0f);
  #ifdef _VISION_PS3
    float temp = pack_2half(half2(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor)));
    Out.DepthSpec = unpack_4ubyte(temp);
    //Out.DepthSpec.xy = packNormalizedFloatInTwoBytes(pixelData.fDepth);
    //Out.DepthSpec.zw = float2(0.0f, 0.0f);
  #else
    #ifdef SPECULAR_COLOR_MONO
      Out.DepthSpec = float4(pixelData.fDepth, (pixelData.vSpecColor.x + pixelData.vSpecColor.y + pixelData.vSpecColor.z) * 0.33333f, 0.0f, 0.0f);
    #else    
      Out.DepthSpec = float4(pixelData.fDepth, compressFloat3ToFloat_16Bits(pixelData.vSpecColor), 0.0f, 0.0f);
    #endif
  #endif
  return Out;
}


inline PixelDataUnpacked unpackPixelValues(PixelDataPacked packedPixelData)
{
  PixelDataUnpacked unpackedPixel;
  unpackedPixel.vAccInitial = packedPixelData.Accumulation.xyz;
  unpackedPixel.fDepth = packedPixelData.DepthSpec.x;
  unpackedPixel.vNormal = (packedPixelData.Normal.xyz*2.0f) - 1.0f;
  unpackedPixel.vDiffColor = packedPixelData.Diffuse.xyz;
  #ifdef SPECULAR_COLOR_MONO
    unpackedPixel.vSpecColor = packedPixelData.DepthSpec.yyy;
  #else
    unpackedPixel.vSpecColor = expandFloatToFloat3_16Bits(packedPixelData.DepthSpec.y);
  #endif
  unpackedPixel.fSpecExp = packedPixelData.Diffuse.w;
  return unpackedPixel;
}


inline float3 positionForDepth(float fDepth, float3 vEyePos, float3 vViewDir)
{
  float3 vRes = vEyePos + fDepth * vViewDir;
  return vRes;
}

#endif


struct PS_IN
{
#ifdef _VISION_DX11
  float4 ProjPos  : SV_Position;
#else
  float4 ProjPos  : POSITION;
#endif
  
#ifdef USE_COLOR
  float4 Color : COLOR0;
#endif
  
#if defined( USE_UV0 ) || defined( USE_UV1 )
  float4 UV0AND1 : TEXCOORD0;
#endif

  float3 Normal  : TEXCOORD1;
#ifdef USE_TANGENT
  float3 Tangent : TEXCOORD2;
  float3 BiTangent: TEXCOORD3;
#endif

#ifdef PERMUTATION_SpotLight
  float4 ProjTexCoord : TEXCOORD4;
#endif

#ifdef PERMUTATION_ProjPointLight
  float3 ProjDir : TEXCOORD4;
#endif  

#if defined(USE_FOGCOORD) || defined(USE_WORLD_POSITION)
  float4 fogCoordAndWorldPos : TEXCOORD5;
#endif
  
  float4 ScreenPosition : TEXCOORD6;

#ifdef USE_LIGHT_WS
  float3 LightWS : TEXCOORD7;
#endif


#ifdef DEFERRED_RENDERING
float4 EyeDirAndDepth : TEXCOORD7;
#endif

};

#ifdef DEFERRED_RENDERING
	DEFERRED_OUT ps_main( PS_IN In )
#else
	#ifdef _VISION_DX11
	float4 ps_main( PS_IN In ) : SV_Target
	#else
	float4 ps_main( PS_IN In ) : COLOR
	#endif
#endif
{
 
  #ifdef USE_FOGCOORD
	float FogCoord = In.fogCoordAndWorldPos.w;
  #endif
  
  #ifdef USE_WORLD_POSITION
	float3 WorldPosition = In.fogCoordAndWorldPos.xyz;
  #endif

  #ifdef USE_EYEDIR
    float3 EyeDir = normalize(gCamPos.xyz - WorldPosition);
  #endif
  
  
/*!float
0.5
*/
//! MARKER - c54cfa38b3654eb194dfd32a75acbefe

/*!float
1
*/
//! MARKER - a5c059cd9e2b490a83835c899ee59b75

/*!float
1
*/
//! MARKER - ddb119d9f4e94695a1549c48dc1fd8fa
float VAR_c08ec3efb0d2466aaefc91a69565a0df = sin( 1 * gTime.x );
			float VAR_0140be2b9c684d32a589dd6f8f2b34ff = cos( 1 * gTime.x );
			float2 VAR_075e25ccaf264f4f9057e41003757eef = float2( ((In.UV0AND1.xy.x-0.5) * VAR_0140be2b9c684d32a589dd6f8f2b34ff) - ((In.UV0AND1.xy.y-0.5) * VAR_c08ec3efb0d2466aaefc91a69565a0df), ((In.UV0AND1.xy.y-0.5) * VAR_0140be2b9c684d32a589dd6f8f2b34ff) + ((In.UV0AND1.xy.x-0.5) * VAR_c08ec3efb0d2466aaefc91a69565a0df) ) + float2( 0.5, 0.5 );
/*!float2
VAR_075e25ccaf264f4f9057e41003757eef
*/
//! MARKER - bbc0e2b959e24300ad5cf4852156e49e
#ifdef PREVIEW
			float4 VAR_e275ef1313f342d0a91bb1b669ca75da = tex2D( BaseTexture_Sampler, VAR_075e25ccaf264f4f9057e41003757eef );
			#else
			
			#ifdef _VISION_DX11
			float4 VAR_e275ef1313f342d0a91bb1b669ca75da = BaseTexture.Sample( BaseTexture_Sampler, VAR_075e25ccaf264f4f9057e41003757eef );
			#else
			float4 VAR_e275ef1313f342d0a91bb1b669ca75da = tex2D( BaseTexture, VAR_075e25ccaf264f4f9057e41003757eef );
			#endif
			#endif
/*!float
VAR_e275ef1313f342d0a91bb1b669ca75da.r
*/
/*!float
VAR_e275ef1313f342d0a91bb1b669ca75da.g
*/
/*!float
VAR_e275ef1313f342d0a91bb1b669ca75da.b
*/
/*!float
VAR_e275ef1313f342d0a91bb1b669ca75da.a
*/
/*!float4
VAR_e275ef1313f342d0a91bb1b669ca75da
*/
//! MARKER - 48fa82fb15224cbda7d364c50b492345
float VAR_7198dcc2267a431aaca0b9befb26ff2a = gTime.x;
/*!float
VAR_7198dcc2267a431aaca0b9befb26ff2a
*/
//! MARKER - b980927166bb4b53835efd40b1d7b9b7

/*!float
2
*/
//! MARKER - 34c926fc7183488e9cfd9ff690ecb759
float VAR_7ef88a5688fd494281bec49efac41a5d = (VAR_7198dcc2267a431aaca0b9befb26ff2a * 2);
/*!float
VAR_7ef88a5688fd494281bec49efac41a5d
*/
//! MARKER - 8115afa8a09c4410a8353f319ba63186
float VAR_468869f319fd4aaeaffad06a10a0ed64 = sin( VAR_7ef88a5688fd494281bec49efac41a5d );
/*!float
VAR_468869f319fd4aaeaffad06a10a0ed64
*/
//! MARKER - 2bc2c5d47cb746c99f73bf8bdf587184
float VAR_2ebf642bdad94dc8871af081dba55455 = (VAR_468869f319fd4aaeaffad06a10a0ed64 + 1);
/*!float
VAR_2ebf642bdad94dc8871af081dba55455
*/
//! MARKER - dc6110129418476895f3d10c262aa2a9
float VAR_2ab84861801c4bcd8a1539cd8fbbc131 = (VAR_2ebf642bdad94dc8871af081dba55455 * 0.5);
/*!float
VAR_2ab84861801c4bcd8a1539cd8fbbc131
*/
//! MARKER - 0330bb8a675448afb722214aeaaf4148
float VAR_489d238fafd8410cb155a02450663c1a = (VAR_e275ef1313f342d0a91bb1b669ca75da.a * VAR_2ab84861801c4bcd8a1539cd8fbbc131);
/*!float
VAR_489d238fafd8410cb155a02450663c1a
*/
//! MARKER - 84ca9ccf7d69467e942f5797a6576c22
float4 VAR_a09c38a0f88b4c8484d29e9ffe7636f0 = float4( VAR_e275ef1313f342d0a91bb1b669ca75da.r, 0.0, VAR_2ab84861801c4bcd8a1539cd8fbbc131, VAR_489d238fafd8410cb155a02450663c1a );
/*!float4
VAR_a09c38a0f88b4c8484d29e9ffe7636f0
*/
//! MARKER - 1616b2fc0a0840b7a526b0248826bb77
return VAR_a09c38a0f88b4c8484d29e9ffe7636f0;
//! MARKER - fa98b583107647b694cb422c44152eed


}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_3_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT FadeOut_Simple {
  DESCRIPTION = {};
  TECHNIQUE "FadeOut_Simple"
  {
    passes="FadeOut_Simple";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT FadeOut_Advanced {
  DESCRIPTION = {};
  TECHNIQUE "FadeOut_Advanced"
  {
    passes="FadeOut_Advanced";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

