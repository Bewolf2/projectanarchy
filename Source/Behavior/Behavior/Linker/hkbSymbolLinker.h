/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

#ifndef HKB_SYMBOL_LINKER_H
#define HKB_SYMBOL_LINKER_H

#include <Common/Base/Container/StringMap/hkStringMap.h>

class hkbSymbolIdMap;

/// Builds and maintains an index of symbols so that various objects can map symbol IDs between them.
/// 
/// Certain hkbehavior objects, such as hkbBehaviorGraphs and hkbSequences, can have their own internal
/// lists of symbols.  Each such list is a map from integers to string names.  It is common for such
/// objects to want to communicate.  For example, the events generated by one hkbBehaviorGraph may need to 
/// be understood by another hkbBehaviorGraph.  The hkbSymbolLinker maintains a symbol table and creates
/// ID mappings between new symbol lists, and the list maintained by the hkbSymbolLinker.  This allows
/// several objects to share a single enumeration of symbols.
///
/// In typical usage, an hkbSymbolLinker would be instantiated, and link() would be called to add
/// new symbols to the symbol table and create a mapping between the incoming symbols and the 
/// symbol table.  For example, you can link together the events of several hkbBehaviorGraphs so that 
/// each hkbBehaviorGraph has a mapping to the list of events maintained by the hkbSymbolLinker.  Once you
/// have linked all of the objects that you want, you may discard the hkbSymbolLinker, and continue to 
/// use the hkbSymbolIdMaps returned by link().
/// 
/// Consider an example.  Suppose that an hkbBehaviorGraph B1 defines the events:
/// 
///    (0, "startJumping")
///    (1, "quit" )
///    (2, "stopJumping" )
/// 
/// Another hkbBehaviorGraph B2 defines these events:
/// 
///    (0, "smile")
///    (1, "stopJumping")
///    (2, "startJumping")
/// 
/// The purpose of the hkbSymbolLinker is to build a global indexing of event names, and provide a map
/// for each behavior to map its event IDs to the global list.  If you call link() twice passing in the event names
/// from B1, and then B2, the resulting symbol table (global event name map) will be:
/// 
///    (0, "startJumping")
///    (1, "quit" )
///    (2, "stopJumping" )
///    (3, "smile" )
/// 
/// When linking the names of B1s events, the resulting hkbSymbolIdMap would be:
/// 
///    (internal, external)
///    (0, 0)
///    (1, 1)
///    (2, 2)
/// 
/// The map for B2 would be:
/// 
///    (0, 3)
///    (1, 2)
///    (2, 0)
/// 
/// Now if the events from one behavior need to be passed to the other behavior, they can
/// be passed through both maps so that identically named events are translated into 
/// the native indexing scheme of the recipient.
///
class hkbSymbolLinker
{
	public:
		HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR( HK_MEMORY_CLASS_BEHAVIOR, hkbSymbolLinker );

			/// Create an hkbSymbolLinker with an empty symbol table.
		hkbSymbolLinker();

			/// Create an hkbSymbolLinker with an initial symbol table.
			/// 
			/// This is useful if you want to ensure that certain symbols maps to certain IDs.
			/// Otherwise, the symbols are assigned IDs dynamically.
		hkbSymbolLinker( const char *const* initialSymbolNames, int numInitialSymbolNames );

		hkbSymbolLinker( hkStringPtr* initialSymbolNames, int numInitialSymbolNames );

			/// Link a new set of symbol names and return a map between the input symbol IDs and the
			/// IDs of the symbol table.
			///
			/// The "internal" indices in the returned map correspond to indices into the symbolNames list,
			/// so they range from 0 to numSymbolNames - 1.  The "external" indices in the returned
			/// map correspond to indices in the symbol table that is being build by the hkbSymbolLinker.
		hkbSymbolIdMap* link( const char *const* symbolNames, int numSymbolNames );

		hkbSymbolIdMap* link( const hkStringPtr* symbolNames, int numSymbolNames );

			/// Add a new symbol name at the next available index/ID.  Returns the symbol ID.
		int addSymbol( const char* name );

			/// Add a list of symbols at the next available index/ID.
		void addSymbols( const char *const* symbolNames, int numSymbolNames );

			/// Add a list of symbols at the next available index/ID.
		void addSymbols( const hkStringPtr* symbolNames, int numSymbolNames );
		
			/// Clears all mappings in the linker
		void clear();

			/// The list of symbol names (a map from IDs to names).
		hkArray<hkStringPtr> m_idToNameMap;

			/// The mapping from symbol names to IDs.  The memory for these strings is managed
			/// by the hkStringPtrs above, so only they should be put into this map.
		hkStringMap<int> m_nameToIdMap;
};

#include <Behavior/Behavior/Linker/hkbSymbolLinker.inl>

#endif

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
