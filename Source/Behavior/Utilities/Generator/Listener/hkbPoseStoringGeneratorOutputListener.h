/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

#ifndef HKB_POSE_STORING_GENERATOR_OUTPUT_LISTENER_H
#define HKB_POSE_STORING_GENERATOR_OUTPUT_LISTENER_H

#include <Behavior/Behavior/Generator/hkbGeneratorOutputListener.h>

extern const class hkClass hkbPoseStoringGeneratorOutputListenerStoredPoseClass;

extern const class hkClass hkbPoseStoringGeneratorOutputListenerClass;

	/// An output listener that stores the pose as it is generated.
class hkbPoseStoringGeneratorOutputListener : public hkbGeneratorOutputListener
{
	public:

		HK_DECLARE_CLASS_ALLOCATOR( HK_MEMORY_CLASS_BEHAVIOR );
		HK_DECLARE_REFLECTION();

		hkbPoseStoringGeneratorOutputListener();
		~hkbPoseStoringGeneratorOutputListener();

			// hkbGeneratorOutputListener interface implementation.
		virtual void handleOutput( const hkbNode& node, const hkbGeneratorOutput& output ) HK_OVERRIDE;

			/// A class that stores the node, pose and the world from model. 
			/// 
			/// You should provide an instance of this class for the nodes you are interested in.
			/// After a call to generate/modify the output of the given node is copied into the
			/// m_pose and m_worldFromModel and m_isPoseValid is set to true which can then be used later.
		class StoredPose : public hkReferencedObject
		{
			public:
				//+vtable(true)
				HK_DECLARE_CLASS_ALLOCATOR( HK_MEMORY_CLASS_BEHAVIOR );
				HK_DECLARE_REFLECTION();

				StoredPose();

					/// The node for which the output pose and the world from model needs to be stored.
				hkbNode* m_node;

					/// Pose generated by m_node. The node can be either a modifier or a generator.
					///
					/// If a node is a modifier then the pose after modify is copied into m_pose.
					/// Also if modifiers are shared then m_pose would have the pose after the
					/// last call to modify.
				hkArray<hkQsTransform> m_pose;

					/// World from model
				hkQsTransform m_worldFromModel;

					/// Whether m_pose and m_worldFromModel is valid or not.
				    ///
					/// Even if an instance of this class has been provided the node might not
					/// get called because it is not currently active. If the node is active
					/// the pose and the world form model gets copied and m_isPoseValid is set
					/// to true. if m_isPoseValid is false you can skip this nodes output.
					/// You need to reset this before call to behavior graph generate.
				hkBool m_isPoseValid;

			public:

				StoredPose( hkFinishLoadedObjectFlag flag ) : hkReferencedObject(flag), m_pose(flag) {}
		};


			/// Array of stored poses
			/// 
			/// You need to fill this array appropriately. On the SDK side while inserting
			/// StoredPoses you must add an extra reference as the destructor removes
			/// reference on these.
		hkArray<StoredPose*> m_storedPoses;

			/// If you change m_storedPoses then you needs to set this to true. So that
			/// the internal map can be recomputed.
		hkBool m_dirty;

	private:
		
		typedef hkPointerMap<const hkbNode*,int>* NodeToIndexMapPtr;

			/// A map from nodes to the indices in m_storedPoses. 
			///
			/// For every element in the m_storedPoses there is a pair in m_nodeToIndexMap.
			/// The key is the node itself and the value is the index into m_storedPoses.
		NodeToIndexMapPtr m_nodeToIndexMap; //+nosave

		void recomputeNodeToIndexMap();

	public:

		hkbPoseStoringGeneratorOutputListener( hkFinishLoadedObjectFlag flag ) 
		:	hkbGeneratorOutputListener(flag),
			m_storedPoses(flag) 
		{
			if( flag.m_finishing )
			{
				m_nodeToIndexMap = new hkPointerMap<const hkbNode*,int>();
			}
		}
};

#endif

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
