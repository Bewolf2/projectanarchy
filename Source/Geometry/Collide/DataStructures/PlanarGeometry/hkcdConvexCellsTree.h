/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

#ifndef HKCD_SPATIAL_CELL_GRAPH_H
#define HKCD_SPATIAL_CELL_GRAPH_H

#include <Geometry/Collide/DataStructures/PlanarGeometry/hkcdPlanarGeometry.h>
#include <Geometry/Collide/DataStructures/PlanarGeometry/Memory/hkcdConvexCellsCollection.h>
#include <Geometry/Collide/DataStructures/IntAabb/hkcdIntAabb.h>

#include <Common/Base/Container/LocalArray/hkLocalBuffer.h>
#include <Common/Base/Algorithm/Collide/1AxisSweep/hk1AxisSweep.h>

class hkcdSolidPlanarGeometry;

/// A binary tree of convex cells. The root node is generally
/// a box (typically initialized to an AABB larger than the object). Child cells are generated by cutting parent cells with a plane.
class hkcdConvexCellsTree : public hkcdPlanarEntity
{
	public:

		HK_DECLARE_CLASS_ALLOCATOR(HK_MEMORY_CLASS_GEOMETRY);

		// Types
		typedef hkcdConvexCellsCollection::Cell				Cell;
		typedef hkcdConvexCellsCollection::CellId			CellId;
		typedef hkcdConvexCellsCollection::Labels			CellLabel;
		typedef hkcdPlanarGeometry::DefaultOrientationCache	OrientationCache;

	public:

		/// Boundary plane / polygon indices in the m_boundingPlanes / m_boundingPolys arrays.
		enum Bounds
		{
			POS_X	= 0,	// (+1, 0, 0)
			NEG_X	= 1,	// (-1, 0, 0)
			POS_Y	= 2,	// (0, +1, 0)
			NEG_Y	= 3,	// (0, -1, 0)
			POS_Z	= 4,	// (0, 0, +1)
			NEG_Z	= 5,	// (0, 0, -1)

			NUM_BOUNDS	= 6,
		};

		/// Types of surfaces used to infer cell labels
		enum PolygonSurfaceType
		{
			POLY_SURFACE_OPEN			= 0,
			POLY_SURFACE_DIRECT			= 0x01,
			POLY_SURFACE_INDIRECT		= 0x02,
			POLY_SURFACE_WATERTIGHT		= POLY_SURFACE_DIRECT | POLY_SURFACE_INDIRECT,			
			POLY_SURFACE_INVALID		= 0x04,

			POLY_VISITED_FLAG			= 0x10,
		};

	public:

		/// Constructor for compatibility with previous approach using geom
		hkcdConvexCellsTree(hkcdPlanarGeometry* geom, bool useNewGeometry);

		/// Copy constructor
		hkcdConvexCellsTree(const hkcdConvexCellsTree& other, bool duplicateGeometry = false);

		/// Destructor
		virtual ~hkcdConvexCellsTree();

	public:

		/// Build a convex cell tree out of a solid bsp  tree
		void buildFromSolidPlanarGeom(hkcdSolidPlanarGeometry* planes, bool buildConnectivity = false);

		/// Splits the given cell by the given plane. Updates all adjacency information
		void splitCell(CellId cellId, PlaneId splitPlaneId, OrientationCache& orientationCache, CellId& insideCellIdOut, CellId& outsideCellIdOut);

		/// Creates a box cell that encloses the entire "known" space
		CellId createBoundaryCell();

		/// Collects all the leaf cells
		void collectLeafCells(hkArray<CellId>& cellIdsOut) const;

		/// Collects all the cells marked as solid
		void collectSolidCells(hkArray<CellId>& cellIdsOut) const;

		/// Collects all the cells marked as empty
		void collectEmptyCells(hkArray<CellId>& cellIdsOut) const;

		/// Converts the given cell to geometry
		void extractCellGeometry(CellId cellId, hkGeometry& cellGeomOut) const;

		/// Converts the boundary connections to geometry
		void debugPrint() const;

		/// Computes the approximate position of the vertices of the given convex cell (floating point precision)
		void computeCellVertices(CellId cellId, hkArray<hkVector4>& verticesPos) const;

		/// Removes all cells not marked as cellLabel
		void removeCellsOfType(CellLabel cellLabel);

		/// Extracts a solid planar geometry from a subset of selected cells
		hkcdSolidPlanarGeometry* buildSolidPlanarGeomFromSubsetOfCells(const hkArray<CellId>& cellIdsIn);

		/// Compute and creates boundary polygons for a given set of cells. Requires connectivity
		void extractBoundaryPolygonsFromCellIds(const hkArray<CellId>& cellIdsIn, hkcdPlanarGeometry& geomOut, hkArray<PolygonId>& boundaryPolygonIdsOut);

		/// Returns a list of unique polygon ids from a set of cells
		void getUniquePolygonIdsFromCellIds(const hkArray<CellId>& cellIdsIn, hkArray<PolygonId>& polygonIdsOut);

		/// Returns a set of cell ids representing disconnected islands of solid regions
		void computeSolidRegionIslands(hkArray< hkArray<CellId> >& islands);

		/// Updates the state of each cell by copying the label of the node of the provided solid planar geometry
		void relabelCellsFromSolid();

		/// Re-assigns the labels of a bsp tree using the label store in the convex cell tree
		void reassignSolidGeomLabels(const hkcdPlanarGeometry& originalGeom, const hkArray<PolygonId>& originalBoundaryPolygonIds, hkcdPlanarEntityDebugger* debugger = HK_NULL);

		/// Remap all the plane ids to incorporate a new Plane collection
		void remapPlanes(const hkcdPlanarGeometry* newGeom, const int* HK_RESTRICT planeRemapTable);

		/// Returns whether the tree has been built with connectivity information
		HK_FORCE_INLINE bool hasManifoldCells();

		/// Returns the cell with the given Id
		HK_FORCE_INLINE const Cell& getCell(CellId cellId) const;
		HK_FORCE_INLINE Cell& accessCell(CellId cellId);

		/// Returns the cells collection
		HK_FORCE_INLINE const hkcdConvexCellsCollection& getCells() const;
		HK_FORCE_INLINE hkcdConvexCellsCollection& accessCells();

		/// Computes the number of boundary planes
		HK_FORCE_INLINE int getNumBoundaryPlanes(CellId cellId) const;

		/// Gets / sets the requested world boundary plane
		HK_FORCE_INLINE PlaneId getWorldBoundaryPlaneId(Bounds b) const;
		HK_FORCE_INLINE void setWorldBoundaryPlaneId(Bounds b, PlaneId pid);

		/// Returns the mesh
		HK_FORCE_INLINE const hkcdPlanarGeometry* getGeometry() const;

		/// Sets the solid planar geometry associated to this tree
		HK_FORCE_INLINE void setSolidPlanarGeom(hkcdSolidPlanarGeometry* sGeom);

	protected:

		/// Creates a polygon for the given splitting plane
		HK_FORCE_INLINE void createSplittingPolygon(PlaneId splitPlaneId, PlaneId* boundsOut) const;

		/// Adds a closing polygon cap created from the given splitting plane
		HK_FORCE_INLINE PolygonId addClosingCap(const PlaneId* cellPlaneIds, int numPlanes, OrientationCache& orientationCache, PlaneId splitPlaneId);

		/// Check if the direction cell to polygon is valid
		HK_FORCE_INLINE bool canGoFromCellThroughPoly(CellId fromCellId, PolygonId throughPolygonId, bool fromOutside);

		/// Infers in/out labels by flood filling thanks to the boundary properties computed on each polygon of each cell
		void inferCellsLabels(hkcdPlanarEntityDebugger* debugger = HK_NULL);

		/// From a set of polygons of the original geometry, mark all the boundary of all the cells with an intersection test
		void markBoundaryCells(const hkcdPlanarGeometry& originalGeom, const hkArray<PolygonId>& originalBoundaryPolygonIds, hkcdPlanarEntityDebugger* debugger = HK_NULL);

		/// Updates the connectivity information for a given polygon after a split
		void updateConnectivity(CellId cellId, PolygonId splitPolygonId, PolygonId insidePolyId, PolygonId outsidePolyId, PlaneId splitPlaneId);

		/// Finds an empty cell
		CellId findOutputCell();

		/// Computes the AABB of the given cell
		void computeCellAabb(CellId cellId, hkcdIntAabb& aabbOut, hkArray<hkcdIntAabb>& boundaryAabbsOut) const;

	protected:

		hkcdConvexCellsCollection m_cells;			///< The array of cells
		hkRefPtr<hkcdPlanarGeometry> m_mesh;		///< A planar mesh, to manage the planes and polygons
		hkcdPlaneCollection* m_planes;				///< Fast access to the plane collection of the geometry

		PlaneId m_boundingPlanes[NUM_BOUNDS];		///< Bounding planes
		PolygonId m_boundingPolys[NUM_BOUNDS];		///< Bounding polygons

		bool m_buildCellConnectivity;				///< Whether the tree is kept manifold and conectivity computed between cells
		hkcdSolidPlanarGeometry* m_solidMesh;		///< Solid form which the convex cell tree is built form (could replace m_mesh in the future)
};

#include <Geometry/Collide/DataStructures/PlanarGeometry/hkcdConvexCellsTree.inl>

#endif	//	HKCD_SPATIAL_CELL_GRAPH_H

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
